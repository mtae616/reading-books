# 저장소와 검색
- 로그 구조 계열(NoSQL)
- 페이지 지향(B tree)

## 데이터베이스를 강력하게 만드는 데이터 구조
- log 계열을 설명하며 map 구조와 같은 구현으로 설명
  - key 를 기준으로 계속 덮어 씌운다
  - 다만, search 는 빠르지 않다 -> 키를 기준으로 계속 찾아야 하기 때문에
  - 따라서 index 를 설정한

## SSTable, LSM Tree
- 키로 정렬된 형식 -> 정렬된 문자열 테이블(SSTable)
  - sstable 의 세그먼트가 통합되는 과정은 mergesort 와 비슷하므로 빠르다
  - 같은 키가 있는 경우 가장 최신의 값으로 유지한다
  - 특정 키를 찾기 위해 모든 색인을 유지할 필요가 없다
    - 드문 드문 있더라도 사이에 있다는 것을 유추할 수 있다

## SSTable 생성과 유지
- in-memory balanced tree 에 데이터를 유지한다 (memtable)
- memtable 의 데이터가 수메가바이트 정도가 되면 ss table 에 삽입한다
- 읽기 요청을 할 때는 멤테이블 -> 가장 최근의 세그먼트 -> 그 다음 세그먼트 ... 순서로 한다

## SSTable 에서 LSM 트리 만들기
- 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진을 LSM 저장소 엔진이라고 한다

## 성능 최적화
- Bllom filter
  - 모든 디스크에서 찾지 않도록 하게 하는 기술
  - bit 배열을 하나 두고 어떤 데이터를 해쉬를 돌려서 만약 있다면 표시해둠 
- SSTable 압축하고 병합하는 전략
  - 크기 계층
  - 레벨 컴팩션

## B Tree
- 블록/페이지에 읽기 쓰기를 한다
- tree 구조로 하나의 페이지가 다른 페이지를 참조할 수 있다
  - 포인터와 비슷하지만 메모리 대신 디스크에 있음
- 참조하며 따라가면 leaf page 에 도달

## 신뢰할 수 있는 B 트리 만들기
- B Tree 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어 쓴다
  - 덮어쓰더라도 페이지를 가리키는 모든 참조는 온전하게 남는다
- DB 가 에러 상황에서 스스로 복구하지 위해 WAL(redo log) 라고 하는 데이터를 추가해 복구한다

## B 트리 최적화
- WAL 대신 일부 데이터 베이스는 copy on write scheme 를 사용한다
  - 변경된 페이지는 다른 위치에 기록하고 트리에 상위 페이지의 새로운 버전을 만들어 새로운 위치를 가리키게 한다
- 페이지에 전체 키를 저장하는 게 아니라 축약해 쓰면 공간을 절약할 수 있다
  - 범위만 제공

### B tree와 LSM tree 비교
- LSM 트리는 쓰기가 빠르다
  - 읽기가 느린 이유는 각 SSTABLE, 여러가지 데이터 구조를 확인해야 하기 때문에
  - B tree 는 rebalancing 해야 되지만 memtable 은 덮어 씌우기만 하면 됨
  - 컴팩션 과정이 애플리케이션에 영향을 줄 수 있음
  - 같은 키의 다중 복사본이 다른 세그먼트에 있을 수도 있음 
- B 트리는 읽기가 빠르다

