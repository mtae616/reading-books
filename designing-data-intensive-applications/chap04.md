# 부호화와 발전
- rdbms 는 하나의 스키마를 따른다고 가정
- schema-on-read(문서 모델 db) 는 schema 유연성이 있음
- 데이터타입과 애플리케이션 코드는 양방향 호환성을 유지해야 한다.
  - 하위 호환성
    - 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.
  - 상위 호환성
    - 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.

## 데이터 부호화 형식
- 데이터를 바이트열의 형태로 부호화 해야한다
- 부호화
  - 인메모리 표현에서 바이트 열로의 전환
- 복호화
  - 파싱, 역직렬화, 언마샬링

## JSON 과 XML, 이진 변형
- JSON 은 웹 부라우저에 내장된 지원과 XML 대비 단순하기 때문에 잘 사용됨
- 텍스트 기반이므로 사람이 읽을 수 있다
- 수의 부호화
  - xml 은 수를 digit 으로 표현하지 않기 때문에 구분할 수 없음
  - json 은 문자열과 수를 구분하지만 정수와 부동소수점 수를 구별하지 않고 정밀도를 지정하지 않는다
  - json, xml 은 유니코드 문자열을 지원하지만 binary 는 지원하지 않는다.
  - xml, json 은 모두 스키마를 지원한다

## 이진 부호화
- 조직 내에서만 사용한다면 size 가 큰 json, xml 보단 binary 형태가 나을 수도 있음

### 스리프트와 프로토콜 버퍼
- 스리프트와 프로토콜 버퍼 모두 스키마가 필요하다(IDL 로 작성)
- 스리프트는 바이너리프로토콜, 컴팩트프로토콜이라는 두가지 다른 이진 부호화 형식이 있다
  - 바이너리 프로토콜
    - 필드 태그를 갖고, 어떤 필드를 다루는지 알려줌
    - 유니코드로 이진 부호화
  - 컴팩트 프로토콜
    - 필드 태그와 타입을 단일 바이트로 줄이고 가변 길이 정수를 사용해서 부호화
    - 나머지는 같음
    - 59 -> 34 바이트로 줄임

## 필드 태그와 스키마 발전
- 스키마는 필연적으로 시간이 지남에 따라 바뀌고 이를 스키마 발전이라고 한다
- 필드에 새로운 태그 번호를 부여하는 방식으로 스키마에 새로운 필드를 추가할 수 있다
  - 읽지 않으면 간단히 무시함으로써 상위 호환성을 유지할 수 있다
- 각 필드에 태그 번호가 있는 동안에는 태그 번호가 계속 같은 의미를 가지고 있기 떄문에 새로운 코드가 예전 데이터를 항상 읽을 수 있다.

## 데이터타입과 스키마 발전
- 필드의 데이터타입을 바꾸는 경우에는 값이 정확하지 않거나 잘릴 위험이 있다.
  - 32 비트 정수 -> 64 비트 정수로 바꾸는 것 처럼

### 아브로
- 프로토콜 버퍼와 스리프트와는 다르지만 또 하나의 이진 부호화 형식

## 서비스를 통한 데이터 플로 : REST 와 RPC
- 통신하는 기본적 방법, 클라이언트와 서버
- 서버는 API 를 공개하고 공개한 API 를 서비스라고 한다
  - API 는 표준화된 프로토콜과 데이터 타입(HTTP, URL, SSL/TLS, HTML) 로 구성된다.
- MSA
  - 서버 자체가 다른 서비스의 클라이언트 일 수 있음

## 웹 서비스
- 서비스와 통신하기 위한 기본 프로토콜로 HTTP 를 사용할 때 이를 웹 서비스 라고 함
- REST vs SOAP
  - REST 는 설계 원칙, 프로토콜이 아니다
  - SOAP, Simple Object Access Protocol
    - 웹 서비스 보안(WS-Security)은 고유 식별자로 토큰을 사용하는 것과 같은 보안 조치를 지정함
    - api 요청을 위한 xml 기반 프로토콜
    - 대부분의 http 기능을 사용하지 않는다
    - wsdl, web service description language
    - wsdl 은 클라이언트가 로컬 클래스와 메서드 호출을 사용해 원격 서비스에 접근하는 코드 생성이 가능하다
    - 정적 타입 프로그래밍 언어에는 유용하지만 동적 타입 언어에는 유용성이 떨어진다
 
## 원격 프로시저 호출(RPC) 문제
- RPC 모델은 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 해준다
  - 이런 추상화를 위치 투명성(location transparency) 라고 한다
- 로컬의 호출은 예측이 가능하지만 네트워크 요청은 유실되거나 원격 장비가 느려서 요청에 응답하지 않을 수 있다
  - retry 대책
    - 로컬은 결과를 반환하거나 에러를 반환, 에트워크 요청은 Timeout 으로 무슨 일이 일어났는지 모름
    - 실패한 네트워크 요청을 다시 시도할 때에는 멱등성을 유지
    - 네트워크 요청은 로컬에 비해 많은 요소로 지연 시간이 발생함
    - 네트워크 요청은 모든 매개변수를 부호화 해야 한다. 큰 객체라면 문제가 될 수 있다

## 메세지 브로커
- 래빗MQ, Kafka, ActiveMQ...
- consumer, subscriber
- 메세지 브로커는 특정 데이터 모델을 강요하지 않는다

## 정리
- 새로운 버전을 순회하는 식으로 업그레이드 하는 것이 애플리케이션 변경의 발전성에 도움이 된다
- 데이터 하위 호환성 (새로운 코드가 예전 데이터를 읽을 수 있음), 상위 호환성(예전 코드가 새로운 데이터를 읽을 수 있음) 을 제공하는 방식으로 부호화해야 한다
- 부호화 형식, 속성
  - 프로그래밍 언어에 특화된 부호화는 단일 프로그래밍 언어로 제한되며 상위 호환성과 하위 호황성을 제공하지 못하는 경우가 있다
    - 자바 직렬화
  - json, xml, csv 같은 텍스트 형식을 널리 사용된다, 선택적 스키마 방식은 유용하고 때로는 방해된다. 이 형식들은 데이터 타입에 모호한 점이 있기 때문에 숫자나 이진 문자열과 같은 항목은 주의해야 한다
- 데이터 플로우 모드
  - 데이터베이스에 기록하는 프로세스가 부호화, 데이터베이스에서 읽는 프로세스가 복호화하는 데이터베이스
  - 클라이언트가 요청을 부호화하고 서버는 요청을 복호화하고 응답을 부호화하고 최종적으로 클라이언트가 응답을 복호화하는 RPC 와 REST API
  - 송신자가 부호화하고 수신자가 복호화하는 메세지를 서로 전송해서 노드 간 통신하는 비동기 메세지 전달(메세지 브로커나 액터를 이용)