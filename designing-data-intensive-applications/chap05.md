# 복제
- 여러 장비에 동일한 데이터의 복사본을 유지
  - 필요한 이유
    - 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다
    - 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다
    - 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다

## 리더와 팔로워
- replica
  - db 복사본을 저장하는 각 노드
- 복제 서버 중 하나를 리더(leader, master, primary) 로 지정한다
- 다른 복제 서버는 팔로워(follower, slave, secondary, read replica, hot standby) 로 지정한다
- 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그나 변경 스트림의 일부로 팔로워에게 전송한다

### 동기식 대 비동기식 복제
- 복제가 동기/비동기로 일어날건지
- 동기식
  - 2 phase commit
  - 리더가 팔로워의 복제 수행 여부를 확인함
  - 일관성 있는 최신 데이터 복사본을 가지는 것을 보장
  - 갑자기 리더가 작동하지 않아도 데이터는 팔로워에서 계속 사용할 수 있음을 확신
  - 단점은 동기 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없다
    - replica 가 정상 동작할 때 까지 기다려야 함
- 반동기식
  - 하나의 replica 에 동기식으로 연결, 다른 replica 는 비동기식으로 연결
  - 따라서 한 쪽에서는 데이터를 변경했음을 ack 로 수신하지만, 다른 쪽은 확인할 수 없음
  - 동기식 보다 성능에 이점이 있으면서도 적어도 전달에 대한 보장은 할 수 있음
  - 또한 동기식 replica가 hang 될 경우 failover 가능 
- 비동기식
  - bin log 이벤트만 전달
  - replica 가 전달 받았는지, 변경 했는지 알지 못함
  - source 서버 장애시 failover 됐을 때 데이터 불일치가 있을 수 있음
  - 장점은 source 서버가 전혀 신경쓰지 않기 때문에 성능을 보장한다
  - 또한 replica 에서 무거운 연산으로 지연되더라도 source 는 전혀 영향을 받지 않음
- 참고
  - mysql 에서 어떤 설정을 하지 않으면 기본적으로 비동기식

### 노드 중단 처리
- 개별 노드의 장애에도 전체 시스템이 동작하게끔 유지하고 노드 중단의 영향을 최소화하는 것이 목표
- 리더 기반 복제에서 고가용성은 어떻게 달성할까
- 팔로워 장애: 따라잡기 복구
  - 팔로워가 죽어 재시작 할 경우 bin log 로 따라 잡음
- 리더 장애: 장애 복구
  - failover
  - 자동 장애 복구 다음과 같은 단계로 처리
    - 리더가 장애인지 판단
    - 새로운 리더를 선택
      - 리더의 최신 데이터 변경사항을 가진 replica
    - 새로운 리더 사용을 위해 시스템을 재설정
  - 고려 사항
    - 비동기식 복제를 사용하고, 새로운 리더가 이전 리더의 쓰기를 일부 수신하지 못한 상황에서는 그냥 폐기한다.
    - 2 노드가 자신을 source 라고 생각할 수 있고 이는 split brain 이라고 부른다
    - 리더가 죽었다고 생각할만한 timeout 시간 고려

### 복제 로그 구현
- 구문 기반 복제
  - 모든 statement 를 (insert, delete, update) 를 파싱하고 실행
  - 고려 사항
    - NOW(), RAND() 같은 비결정 함수
      - 이 방법은 고정 값을 반환하게 할 수 있음
    - A.I 가 정확히 같은 순서로 실행돼야 함
    - 트리거, 프로시져가 정확히 같아야 함
- 쓰기 전 로그 배송(wal)
  - 가장 큰 단점은 로그가 제일 저수준의 데이터를 기술한다는 점
  - 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세 정보를 포함한다
  - 따라서 db 스펙일 동일하게 해야한다
- 논리적(로우 기반) 로그 복제
  - 복제와 저장소 엔진을 위해 다른 로그 형식을 사용, logical log 
  - 변경 데이터 캡처 라고 부름
- 트리거 기반 복제
  - trigger, stored procedure
  - 다른 복제 방식보다 많은 오버헤드, 버그, 제한사항이 있다

### 복제 지연 문제
- 확장성 (단일 장비에서 감당하지 못하는 요청 처리)과 지연 시간(사용자에게 지리적으로 더 가까운 복제 서버를 위치시킴) 도 고려해야 한다
- master - write / slave - read
  - read-scaling
  - 만약 slave 가 뒤처진다면 지난 정보를 읽을 수 있다
  - 다만 이런 불일치는 일시적인 상태이고 잠시 기다리면 결국 따라잡는다 -> 최종적 일관성

### 자신이 쓴 내용 읽기
- 자신이 게시글을 쓴 후 slave 가 데이터를 따라잡지 못해 유실된 것 처럼 보이는 경우
- 쓰기 후 읽기 일관성이 필요하다
  - 사용자가 수정한 내용은 리더에서 다른 것은 팔로워에서
    - 만약 대부분의 내용을 수정할 가능성이 있다면 1분간만 리더에서 읽도록 한다
  - idc / 디바이스 간(cross-device) 에 대한 추가적인 고려가 필요하다

### 단조 읽기
- 시간이 거꾸로 흐르는 현상
  - 각기 다른 replica 를 여러 읽기를 수행할 때 발생
  - 첫 번째 읽기에서는 지연이 없었지만 두번쨰 읽기에서는 복제 지연 때문에 찾지 못하는 현상
- 단조 읽기는 이런 형태의 이상 현상이 발생하지 않음을 보장
  - 최종적 일관성 보다는 강한 보장
  - 이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않는다
  - 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것
  - id를 해시 기반으로 복제 서버를 선택
- 일관된 순서로 읽기
  - 인과성의 위반 우려
  - 데이터의 흐름을 순서대로 읽어야 한다
  - 일련의 쓰기가 특정 순서로 발생한다면 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨
  - 많은 분산 db에서 서로 다른 파티션은 독립적으로 동작하므로 쓰기의 전역 순서는 없다
    - 즉, 사용자가 db에서 읽을 때 예전 상태의 일부와 새로운 상태의 일부를 함께 볼 수 있다

## 다중 리더 복제
- 복제는 똑같이 처리하면서 쓰기 처리를 하는 각 노드는 데이터 변경을 다른 모든 노드에 전달
- 이 방식을 다중 리더, active/active replica 라고 함

## 다중 리더 복제의 사용 사례
- 단일 데이터 센터 내에 다중 리더 설정을 사용하는 것은 복잡도에 비해 이점이 떨어진다

### 다중 데이터 센터 운영
- 여러 다른 데이터센터에 replica 가 있는 경우 (전체 데이터 센터의 내결함성을 갖추기 위해 혹은 사용자에게 지리적으로 가까이 위치하기 위해)
- 각 데이터센터 마다 리더가 있고 각 리더가 다른 리더에게 변경 사항을 복제한다

### 오프라인 작업을 하는 클라이언트
- 인터넷 연결이 끊어진 동안 애플리케이션이 계속 동작해야 하는 경우
- 캘린더, 메모 앱 같은 거
- 이 경우 모든 디바이스에 리더처럼 수행하는 로컬 db 가 있음

### 협업 편집
- notion, spread sheet 같은거...

### 쓰기 충돌 다루기
- 다중 리더 복제의 가장 큰 문제
- 단일 리더라면 트랜잭션에 의해 waiting
- 동기식이라면 간단히 해결되지만 다중 리더복제의 주요 장점(각 복제 서버가 독립적으로 쓰기를 허용)을 잃는다
- 충돌 회피
  - 같은 데이터 센터에 접근하게 하는 것
  - 현실적이지 않음
- 일관된 상태 수렴
  - 1 -> A, 2 -> B, 3 -> C 로 변경했을 때 하나의 상태를 유지해야 되는 것
  - 수렴 방식으로 해소할 수 있음
    - 고유 ID 를 부여하고 가장 높은 값을 고름
    - 명시적 데이터 구조에 충돌을 기록해 모든 정보를 보존하고 나중에(사용자에게 보여줄 때) 충돌을 해소하는 애플리케이션 코드를 작성
- 사용자 정의 충돌 해소 로직
  - 애플리케이션 코드를 사용해 충돌 해소 로직을 작성
  
## 충돌은 무엇인가?
- 동일한 레코드의 동일한 필드를 동시에 수정하는 것

### 다중 리더 복제 토폴로지
- 복제 토폴로지
  - 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로
- 전체 연결
  - 모든 리더가 각자의 쓰기를 다른 모든 리더에게 전송
- 원형 토폴로지
  - mysql default
  - 각 노드가 하나의 노드로부터 쓰기를 받고 다른 한 노드에 전달
- 별 모양 토폴로지
  - 중간에 하나가 다른 쪽에 전달
- 원형과 별 모양은 하나의 노드에 장애가 발생하면 다른 노드간 복제 메시지 흐름에 방해를 준다
  - 토폴로지 장애 노드를 회피하게끔 재설정 해야 한다
- 전체 연결 토폴로지는 일부 네트워크 연결이 다른 연결보다 빠르다면 일부 복제 메시지가 다른 메시지를 추월할 수 있다
  - 버전 벡터라는 기법으로 해소

## 리더 없는 복제
- 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용
  - Amazon Dynamo
- 클라이언트가 여러 복제 서버에 쓰기를 직접 존송하는 반면 코디네이터 노드가 클라이언트를 대신해 이를 수행하기도 한다
  - 코디네이터 노드는 특정 순서로 쓰기를 수행하지 않는다

### 노드가 다운됐을 때 데이터베이스에 쓰기
- 리더 없는 설정에서는 노드가 다운되어도 장애 복구가 필요하지 않는다
  - 장애가 발생한 노드에서는 쓰기를 무시한다
  - 장애가 발생한 노드가 복구되고 응답으로 outdated 값을 반환한다
  - 이 문제를 해결하기 위해 클라이언트에서는 읽기 요청을 병렬로 여러 노드에 전송하고 version 을 통해 값들을 비교한다

### 읽기 복구와 안티 엔트로피
- Dynamo style datastore 의 누락된 쓰기를 따라잡는 방법
  - 읽기 복구
    - 버전 값 비교 후 뒤 떨어진 데이터는 갱신
    - 값을 자주 읽는 상황에서 유용하다
  - 안티 엔트로피 추적
    - 백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾는다
    - 상당한 지연이 있을 수 있음

# 정리
replication 의 용도
- 고가용성
  - 한 장비(또는 여러 장비나 전체 데이터센터)가 다운될 때도 시스템이 계속 동작하게 한다
- 연결이 끊긴 작업
  - 네트워크 중단이 있을 때도 애플리케이션이 계속 동작할 수 있게 한다
- 지연 시간
  - 지리적으로 사용자에게 가까이 데이터를 배치해 사용자가 더 빠르게 작업할 수 있게 한다
- 확장성
  - 복제본에서 읽기를 수행해 단일 장비에서 다룰 수 있는 양보다 많은 양의 읽기 작업을 처리할 수 있다

replication 의 주요 접근 방식
- 단일 리더 복제
  - 모든 쓰기를 master 에 보내고 master는 데이터 변경 이벤트 스트림을 다른 replica 로 전송
  - 읽기는 모든 복제 서버가 수행할 수 있지만 replica의 읽기는 오래된 값일 수 있다
- 다중 리더 복제
  - 각 쓰기를 여러 리더 노드 중 쓰기를 받아들일 수 있는 노드로 전송
  - master는 데이터 변경 이벤트 스트림을 다른 master/slave 에 전송
- 리더 없는 복제
  - 클라이언트는 각 쓰기를 여러 노드로 전송
  - 클라이언트는 oudated data 를 감지, 이를 바로 잡기 위해 병렬로 여러 노드에서 읽는

복제 지연으로 발생할 수 있는 이상 현상
- 쓰기 후 읽기 일관성
  - 사용자는 자신이 제출한 데이터를 항상 볼 수 있어야 한다
- 단조 읽기
  - 사용자가 어떤 시점에 데이터를 본 후에는 예전 시점의 데이터는 나중에 볼 수 없다
- 일관된 순서로 읽기
  - 사용자는 인과성이 있는 상태의 데이터를 봐야 한다
  - 질문과 답을 순서에 맞게 봐야 한다