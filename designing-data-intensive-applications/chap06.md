# 파티셔닝
- 데이터 셋이 매우 크거나 처리량이 높다면 복제만으로는 부족하고 파티션으로 쪼갤 필요가 있다
  - 이 책에서는 샤딩을 의미하는듯
- 데이터 파티셔닝을 원하는 주된 이유는 확장성
- 각 노드에서 자신의 파티션에 해당하는 질의를 독립적으로 실행하므로 질의 처리량을 늘릴 수 있음
  - 여러 노드에서 병렬로 실행

## 파티셔닝과 복제
- 복제와 파티셔닝을 함께 적용할 때에는 파티션마다 master/slave 를 정해줘야 함

## 키-값 데이터 파티셔닝
- 쏠림(skewed)가 있으면 파티셔닝의 효과가 매우 떨어진다
  - 뷸균형하게 부하가 높은 파티션을 핫스팟이라고 한다
- 키-값 모델은 기본키로 접근하므로 핫스팟 문제를 회피할 수 있다

### 키 범위 기준 파티셔닝
- 각 파티션의 경계를 알면 어떤 키가 어느 파티션에 속하는지 쉽게 찾을 수 있다
- 데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞춰 조정해야 한다
- 각 파티션 내에서는 키를 정렬된 순서로 저장할 수 있다
  - mysql range partition

### 키의 해시값 기준 파티셔닝
- 좋은 해시 함수는 쏠린 데이터를 입력으로 받아 균일하게 분산되게 한다
- 해시값을 기준으로 범위를 할당하고 해시값이 파티션의 범위에 속하는 모든 키를 그 파티션에 할당하면 된다
- 다만 range query 어려움, rebalancing 해야됨

### 쏠린 작업부하와 핫스팟 완화
- 해시 키로 잡아도 핫스팟은 생김
  - SNS 에서 유명인의 피드...
- 데이터 시스템에서는 쏠린 작업부하를 자동으로 보정하지 못하므로 애플리케이션에서 쏠림을 완화해야 한다
  - 요청이 매우 몰리는 키를 발견했을 때 각 키의 시작이나 끝에 임의의 숫자를 붙이는 것
  - 따라서 키들을 다른 파티션으로 옮길 수 있다
  - 그러나 100개로 나눴다고 했을 때에는 100개를 모두 불러와서 데이터를 조합해야하므로 추가적인 작업이 필요해진다
  - 이 기법은 요청이 몰리는 소수의 키에만 적용하는 것이 타당하다

## 파티셔닝과 보조 색인
- 보조 색인은 파티션에 깔끔하게 대응되지 않는 문제점이 있다

### 문서 기준 보조 색인 파티셔닝
- 문서 id 가 partition key 인데 다른 컬럼으로 검색하는 경우
  - 각 파티션이 독립적으로 동작하므로 모든 파티션(각각의 local index) 를 full scan
  - 위와 같은 방법을 scatter/gather 라고 하고 꼬리 지연 시간 증폭이 발생하기 쉽다

### 용어 기준 보조 색인 파티셔닝
- 모든 파티션의 데이터를 담당하는 global index 를 만들 수도 있음
  - 그러나 index 를 한 노드에만 저장할 수 없음 -> 해당 노드가 병목이 되어 파티셔닝의 목적을 해치기 때문에
  - 따라서 local index 를 유지해야 함
- 특정 컬럼의 용어를 기준으로 partitioning 하는 것을 용어 기준 파티셔닝(term-partitioned) 라고 함

## 파티션 재균형화
- db 에 생기는 변화
  - 질의 처리량이 증가해서 늘어난 부하를 처리하기 위해 CPU 를 더 추가하고 싶다
  - 데이터셋 크기가 증가해서 데이터셋 저장에 사용할 디스크와 램을 추가하고 싶다
  - 장비에 장애가 발생해서 그 장비가 담당하던 역할을 다른 장비가 넘겨받아야 한다
  - 위와 같은 변화가 생기면 데이터와 요청이 한 노드에서 다른 노드로 옮겨져야 한다
  - 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 rebalancing 이라고 한다
- rebalancing 최소 요구 사항
  - 부하(데이터 저장소, 읽기 쓰기 요청)가 클러스터 내에 있는 노드들 사이에 균등하게 분배돼야 한다
  - rebalancing 도중에도 db 는 읽기 쓰기 요청을 받아들여야 한다
  - rebalancing 이 빨리 실행되고 네트워크와 디스크 IO 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옮겨져서는 안 된다

### 재균형화 전략
- 쓰면 안 되는 방법 : 해시 값에 모드 N 연산을 실행
  - mod 가 바뀌면 자주 이동하게 되어 재균형화 비용이 지나치게 커진다
- 파티션 개수 고정
  - 파티션을 노드 대수보다 많이 만들고 각 노드에 여러 파티션을 할당하는 것이다
  - 클러스터에 노드가 추가되면 새 노드는 파티션이 다시 균일하게 분배될 때까지 기존 노드에서 파티션 몇 개를 뺏어올 수 있다
    - 노드가 한 대 추가될 떄 기존 노드들에게 파티션을 하나씩 가져오는 방법
  - 따라서 파티션은 통째로 이동만하면 된다
- 동적 파티셔닝
  - 파티션 경계를 잘못 지정하면 하나에만 쏠리는 현상이 발생할 수 있음
  - 그렇다고 수동으로 재설정하는 것은 매우 성가심
  - HBase 나 resyncDB 는 파티션을 동적으로 만듬
    - 임계치 넘어가면(HBase -> 10GB)
  - 반대로 데이터가 많이 삭제되면 다시 합치기도 함
    - B+Tree 최상위 레벨에서 실행되는 작업과 유사하다
  - 동적 파티셔닝은 키 범위 파티셔닝에만 적합한 것은 아니고 해시 파티셔닝에도 똑같이 적용될 수 있음
    - mongoDB 2.4 부터 키 범위 파티셔닝과 해시 파티셔닝을 모두 지원하고 두 경우 모두 파티션을 동적으로 분할한다

## 운영: 자동 재균형화와 수동 재균형화
- 완전 자동 재균형화 (관리자의 개입이 전혀 없이 시스템이 자동으로 언제 파티션을 노드 사이에 이동할지)
- 완전 수동 재균형화 (관리자가 명시적으로 파티션을 노드에 할당하도록 설정하고 관리자가 재설정할 때만 파티션 할당이 변경됨)
- 위의 두 방법 사이에는 중간 지점이 있다
  - 자동으로 파티션 할당을 제안하지만 반영되려면 관리자가 확정해야됨

## 요청 라우팅
- 클라이언트에서 요청을 보내려고 할 떄 어느 노드로 접속해야 하는지 어떻게 알 수 있을까?
- service discovery
  - 클러스터 메타데이터를 추적하기 위해 ZooKeeper 같은 별도의 코디네이션 서비스를 사용한다
  - 각 노드는 주키퍼에 자신을 등록하고 주키퍼는 파티션과 노드 사이의 신뢰성 있는 할당 정보를 관리한다.

# 정리
파티셔닝의 목적은 핫스팟이 생기지 않게 하면서 데이터와 질의 부하를 여러 장비에 균일하게 분배하는 것

<br />

두가지 주요 파티셔닝 기법
- 키 범위 파티셔닝
  - 키가 정렬돼 있어 범위 질의가 효율적
  - 정렬 순서가 서로 가까운 키에 자주 접근하면 핫스팟이 생길 위험이 있다
- 해시 파티셔닝
  - 키 순서가 보장되지 않아 범위 질의가 비효율 적이지만 부하를 더욱 균일하게 분산할 수 있다
  - 고정된 개수의 파티션을 미리 만들어 각 노드에 몇 개씩의 파티션을 할당하며 노드가 추가되거나 제거되면 파티션을 통쨰로 노드 사이에서 이동한다

보조 색인도 파티셔닝이 필요한데 두가지 방법이 있다
- 문서 파티셔닝
  - 보조 색인을 기본키와 값이 저장된 파티션에 저장한다
  - 쓸 때는 파티션 하나만 갱신하면 되지만 보조 색인을 읽으려면 모든 파티션에 걸쳐서 scatter/gather 를 실행
- 용어 파티셔닝
  - 색인된 값을 사용해서 보조 색인을 별도로 파티셔닝
  - 보조 색인 항목은 기본키의 모든 파티션에 있는 레코드를 포함할 수도 있다
  - 문서를 쓸 때는 보조 색인 여러개를 갱신해야 하지만 읽기는 단일 파티션에서 실행될 수 있다