# 트랜잭션
- commit or rollback
  - safety guarantee

## 애매모호한 트랜잭션의 개념
- 대부분의 db sms IBM R 에서 소개된 트랜잭션 스타일을 따른다
  - mysql, postgresql, oracle, ...
- 트랜잭션의 tade off 를 알아야 함
- ACID 의 의미
  - Atomic
    - 원자적 연산
    - commit or rollback
  - Consistency
    - 불변식 (invariant)
    - 회계 시스템에서 대변과 차변은 항상 맞아 떨어져야 한다
    - 다만 애플리케이션의 책임에 가깝다
  - Isolation
    - 동시에 실행되는 트랜잭션은 서로 격리된다
    - or 트랜잭션이 순차적으로 실행된다
  - Durability
    - 트랜잭션이 커밋 됐다면 하드웨어 결함이 발생하거나 db 가 죽더라도 트랜잭션에 기록한 모든 데이터는 손실되지 않아야 한다
    - wal
  - 완벽한 것은 없다
    - replication 으로 백업이 존재해도 모든 replica 가 죽으면 복구할 방법은 없음
  - 단일 객체 연산과 다중 객체 연산
    - 원자성과 격리성은 한 트랜잭션 내에서 여러 번의 쓰기를 하면 db 가 어떻게 해야 하는지를 서술
  - 단일 객체 쓰기
    - 단일 객체를 쓰면서 네트워크 순단이 발생한 경우에도 wal 을 사용해서 복구 가능
      - 원자성과 격리성을 만족할 수 있다
  - 다중 객체 트랜잭션의 필요성
    - 여러 record 를 cud 하는 경우
      - fk 로 연결된 경우
  - secondary index 가 있는 경우 index 도 cud 해야됨 (다중 객체로 판단한다)

## 오류와 어보트 처리
- 어보트의 취지는 안전하게 재시도할 수 있는데 있다
- 어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 매커니즘이지만 완벽하지는 않다
  - 트랜잭션이 실제로는 성공했지만 서버가 클라이언트에 커밋 성공을 알리는 도중 네트워크가 끊겼을 때 다시 시도하는 경우 2번 실행된다
  - 오류가 과부하 때문이라면 트랜잭션 재시도는 문제를 개선하는 게 아니라 악화시킬 수 있다
  - 일시적인 오류(deadlock, 네트워크 단절, 장애 복구 등) 만 재시도할 가치가 있으며 영구적인 오류(제약 조건 위반)는 재시도해도 소용 없음

## 완화된 격리 수준
- 동시성 문제는 같은 데이터를 조작하려고 할 떄 발생
- 동시성 문제는 재현하기 어렵고 추론하기 어렵다
- 트랜잭션 격리 수준으로 제어한다

## Read committed
- 커밋된 데이터만 조작
- dirty read
  - 커밋되지 않은 데이터를 읽는 것
- 더티 읽기 방지
  - 이 격리 수준에서는 dirty read 는 막힘
  - commit 되거나 rollback 되지 않은 데이터를 읽는 다면 사용자는 혼란스럽다
- 더티 쓰기 방지
  - commit 되거나 rollback 되지 않은 데이터를 덮어써서는 안됨
- read committed 구현
  - locking
    - 비관적 락 얘기일듯 (x-lock, s-lock)

## 스냅샷 격리와 반복 읽기
- nonrepeatable read or read skew
  - 트랜잭션 진행 도중에 커밋되지 않은 데이터를 읽어 일관되지 않은 데이터를 확인하는 경우
  - 500/500 계좌 2개로 나눠 놓고 한 계좌에서 다른 계좌로 100원 보냄
  - 트랜잭션 도중에 계좌 A 에서 500을 확인하고 트랜잭션이 마감되면 계좌 B 에서는 400 을 확인하면서 총 계좌가 900원 으로 확인됨
  - 새로고침 하면 정상 확인 되지만 용인되지 않는 경우도 있음
- 스냅샷 격리 구현
  - 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서는 읽는 쪽을 결코 차단하지 않는다
  - MVCC
    - 커밋된 데이터 버전을 여러개로 유지한다
    - txid 를 부여하고 현재 진행하는 트랜잭션 id 보다 더 낮은 숫자의 txid 를 가진 데이터를 확인한다
- 일관된 스냅샷을 보는 가시성 규칙
  - 어떤 것을 볼 수 있는지 없는지 결정
  - 어보트된 데이터는 모두 무시되고 더 작은 txid 를 가진 데이터만 질의로 확인 가능
  - 생성/삭제 마찬가지임

## 갱신 손실 방지
- 두 트랜잭션이 동시에 실행될 떄 하나의 트랜잭션 연산만 반영되는 경우
- 원자적 쓰기 연산
  - CAS
  - 몽고db 는 json 문서의 일부를 지역적으로 변경하는 원자적 연산을 제공
  - redis 는 priority queue 로 데이터 구조를 변경하는 원자적 연산을 제공
  - 보통 x-lock 으로 구현됨
- 명시적인 잠금
  - db 가 원자적 연산을 제공하지 않을 때는 객체를 명시적으로 잠그는 것
  - for update 로
- 갱신 손실 자동 감지
  - 원자적 연산과 잠금은 read-modify-write 주기가 순차적으로 실행되도록 강제하는 것
  - 대안으로는 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 어보트시키고 read-modify-write 주기를 재시도하도록 강제하는 것

## 쓰기 스큐와 팬텀
- 쓰기 스큐
  - 애플리케이션에서 정의한 규칙을 위반하는 쓰기가 발생하는 경우
    - 의사는 꼭 1명이 대기해야 하는데, 2명이 동시에 휴식하게 되어 대기하는 의사가 없는 경우
  - 다수의 트랜잭션이 같은 객체들을 읽어서 그중 일부를 갱신할 때 나타날 수 있음
  - 방지하는 방법
    - serializable, x-lock 등

## 충돌 구체화
- 문제가 잠글 수 있는 객체가 없다는 것이라면 인위적으로 db에 잠금 객체를 추가해야 한다
- for update 를 위해 (x-lock)

## 직렬성
- read committed 나 repeatable read 로 방지하기 어려운 경우
- 동시성 없이 한 번에 하나씩 직렬로 실행된다
- 단일 스레드 루프에서 트랜잭션을 실행
  - 가능하게 된 이유
  - 램 가격이 저렴해져서 활성화된 데이터셋 전체를 메모리에 유지
  - 레디스, 데이토믹, 볼트db 등
  - 처리량은 cpu 코어 하나의 처리량으로 제한된다
- 직렬성이 실용적인 방법이 되는 요건
  - 모든 트랜잭션은 작고 빨라야 한다. 느린 트랜잭션 하나가 모든 트랜잭션 처리를 지연시킬 수 있기 때문이다.
  - 활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한된다.
  - 쓰기 처리량이 단일 cpu 코어에서 처리할 수 있을 정도로 충분히 낮아야 한다
  - 여러 파티션에 걸친 트랜잭션도 쓸 수 있지만 이것을 사용할 수 있는 정도에는 엄격한 제한이 있다

## 2PL
- two-phase locking
- 쓰기 트랜잭션은 다른 쓰기 트랜잭션뿐만 아니라 읽기 트랜잭션도 진행하지 못하게 막고 그 역도 성립한다

## 직렬성 스냅샷 격리 (SSI)
- 스냅샷 격리에 비해 약간의 성능 손해만 있고, 직렬성을 보장함
- 쓰기 스큐처럼 질의 결과(전제 조건)와 쓰기 작업 사이 인과적 의존성이 있을 때, 전제 조건이 최신 결과가 아니면, 이를 감지해서 트랜잭션을 어보트시켜서 직렬성 격리를 제공한다.
- 낙관적 동시성 제어 기법
  - 일관된 스냅샷을 보게 한다
  - 스냅샷 격리 위에 쓰기 작업 사이의 직렬성 충돌을 감지하고 어보트시킬 트랜잭션을 결정하는 알고리즘을 추가한다
- 뒤처진 전제에 기반한 결정
- 오래된 MVCC 읽기 감지하기
- 과거의 읽기에 영향을 미치는 쓰기 감지하

## 정리
- 더티 읽기: 한 트랜잭션이 다른 트랙잭션이 썼지만 아직 커밋되지 않은 데이터를 읽는다. read committed 이상에서 방지됨.
- 더티 쓰기: 한 트랜잭션이 다른 트랜잭션이 썼지만 아직 커밋되지 않은 데이터를 덮어쓴다. 거의 모든 트랜잭션 구현은 더티 쓰기를 방지함.
- 읽기 스큐(비반복 읽기): 같은 트랜잭션이더라도 읽는 시간에 따라 다른 값을 읽는다. 스냅숏 격리(snapshot isolation, repeatable read) 를 많이 사용한다. mvcc로 구현된다.
- 갱신 손실: 두 클라이언트가 read-modify-write 를 동시에 진행한다. 이로 인해 데이터가 손실된다. 스냅숏 격리 중 일부는 이를 자동으로 어보트하지만 그 외에는(mysql의 repeatable read) 는 select for update 필요
- 쓰기 스큐: 무언가 읽고, 읽은 값을 기반으로 어떤 결정을 한 다음 그 결정을 데이터베이스에 쓴다. 하지만 쓰기를 실행할 때는 결정의 전제가 참이 아니다. 직렬성 격리만 막을 수 있다.
- 팬텀 읽기: 한 트랜잭션이 검색 조건에 부합하는 객체를 읽는다. 다른 트랜잭션이 그 검색 결과에 영향을 주는 쓰기를 실행한다. 스냅숏 격리는 간단한 팬텀 읽기는 막아주지만, 쓰기 스큐의 팬텀은 색인 범위 잠금처럼 처리가 필요하다.(회의실 예약)
