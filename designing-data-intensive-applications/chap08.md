# 분산 시스템의 골칫거리
- 어떤 것이든 잘못될 가능성이 있다면 잘못된다고 가정
- 엔지니어의 임무는 모든 게 잘못되더라도 제 역할을 해내는(사용자가 기대하는) 시스템을 구축하는 것
- 결함과 부분 장애
  - 프로그램은 돌아가거나 안 돌아가거나 둘 중 하나
  - 단일 컴퓨터에서 실행되는 소프트웨어는 하드웨어가 올바르게 동작하면 같은 연산은 항상 같은 결과를 낸다.
  - 하드웨어가 잘못되면 완전 실패
  - 부분장애 : 분산 시스템에서는 어떤 부분은 잘 동작하지만 다른 부분은 예측할 수 없는 방식으로 고장나는 것

## 신뢰성 없는 네트워크
- 분산 시스템은 비공유 시스템(네트워크로 연결된 다수의 장비)
- 인터넷과 데이터센터 내부 네트워크 대부분(특히 이더넷)은 비동기 패킷 네트워크
  - req, res 순서/요청 보장하지 않음
  - 수신 측에서 응답 메세지를 주면 되지만 그조차도 보장하지 않음
  - timeout 을 통해 제어한다

## 현실의 네트워크 결함
- ec2 순단, 스위치 sw update, 네트워크 토폴로지 재구성...etc
- 결함은 언제든지 일어날 수 있다는 것을 인지 -> 언제든지 복구할 수 있도록 보장해야 한다

## 결함 감지
- 결함 있는 노드를 감지할 수 있어야 한다
- slave -> master 승격, healthcheck, failover ...
- 타임아웃과 기약 없는 지연
  - 타임아웃 시간에 간단한 답은 없다
  - 성급하게 노드가 죽었다고 선언하면 추가적인 부하(다른 노드를 승격 등)가 일어난다
  - 단순히 노드가 응답이 느린 것일 수도 있음
  - 죽었다고 판단한 노드의 부하를 다른 노드로 전달하면 연쇄 장애를 유발할 수 있다
- 네트워크 혼잡과 큐 대기
  - 패킷 지연의 변동성은 큐 대기 때문인 경우가 많다
  - 가상 환경에서 실행되는 운영체제는 다른 가상 장비가 CPU 코어를 사용하는 동안 수십 밀리초 동안 멈출 때가 흔하다
    - 이 시간 동안 가상 장비는 네트워크에서 어떤 데이터도 받아들일 수 없으므로 가상 장비 모니터가 들어오는 데이터를 큐에 넣어서 네트워크 지연의 변동성을 더욱 증가시킨다
  - TCP 흐름 제어, 혼잡 회피 나 배압이라고도 하는 흐름 제어는 노드가 네트워크 링크나 수신 노드에 과부하를 가하지 않도록 자신의 송신율을 제한하는 것이다.
    - 데이터가 네트워크로 들어가기 전에도 부가적인 큐 대기를 할 수 있다는 뜻이다

## 신뢰성 없는 시계
- 시계에 의존하는 데이터
1. req timeout
2. 꼬리 지연
3. tps
4. 체류 시간
5. 언제 게시?
6. 며칠 몇시에 알림 이메일?
7. 캐시 만료 시간
8. 로그 파일에 남은 타임스탬프
- 1 ~ 4 는 지속 시간, 5 ~ 8 은 특정 시점

## 단조 시계 대 일 기준 시계
- 일 기준 시계
  - 직관적으로 시계에 기대하는 일
- 단조 시계
  - 타임아웃, 서비스 응답 시간 같은 지속 시간을 재는 데 적합
  - 두 시간 값 사이의 차이로 얼마나 흘렀는지
  - System.nanoTime()
  - 항상 앞으로 흐른다

## 동기화된 시계에 의존하기
- 네트워크 순단에 의해 단조 시계가 흐르지 않을 수 있음
- 다른 노드와 극적인 차이를 보이는 단조 시계를 가진 노드는 죽은 것으로 판단해야 됨

## 가비지 컬렉션의 영향을 제한하기
- GC 중단을 노드가 잠깐 트래픽을 받지 않는 것으로 판단
- GC 를 마치면 다시 트래픽을 받는다
- 응답 시간의 상위 백분위를 줄여준다

## 진실은 다수결로 결정된다
- 죽지 않은 노드를 죽었다고 판단할 수 있음
  - 비대칭 적인 결함 - 메세지를 받지만, 보낼 수는 없는 경우
  - stop the world 가 너무 긴 경우
- 정족수, 노드들 사이의 투표에 의존한다

## 리더와 잠금
- 리더가 필요한 경우
  - split brain 을 피하기 위해 오직 한 노드만 db partition 의 리더가 될 수 있다
  - 자원의 오염을 방지하기 위해 하나의 트랜잭션/클라이언트만 잠금을 획득할 수 있게 하는 경우
  - 사용자명으로 사용자를 유일하게 식별해야 하는 경우
- 분산 시스템에서는 follower 가 leader 가 될 수 있으므로 주의해야 한다

## 비잔틴 결함
- 분산 시스템 문제는 노드가 "거짓말"(임의의 결함이 있거나 오염된 응답을 보냄)을 할지도 모른다는 위험이 있다면 훨씬 더 어려워 진다
- 어떤 노드가 실제로는 받지 않은 특정 메세지를 받앗다고 주장할 수도 있고 이런 동작을 비잔틴 결함이라고 한다
  - 신뢰할 수 없는 환경에서 합의에 도달하는 문제를 비잔틴 장군 문제
- 일부 노드가 오작동하고 프로토콜을 준수하지 않거나 악의적인 공격자가 네트워크를 방해하더라도 시스템이 계속 올바르게 동작한다면 이 시스템은 비잔틴 내결함성을 지닌다
- 웹 애플리케이션은 최종 사용자가 제어하는 웹브라우저 같은 클라이언트의 행동이 임의적이고 악의적이라고 예상해야 한다
  - 사용자의 입력을 살균(input validation) 하고 출력 이스케이핑을 해야 한다
  - sql injection
  - xss

## 정리
- 분산 시스템에서 나타날 수 있는 문제
  - 패킷이 손실/지연, 응답이 손실/지연
  - 노드의 시계가 다른 노드와 맞지 않을 수 있음 -> 시계에 의존하는 것은 위험
  - 프로세스는 어느 시점에 멈출 수 있고 죽었다고 판단될 수 있ㅇ므
- 부분 실패가 일어날 수 있다는 것은 분산 시스템의 특징
  - 가끔씩 실패 / 임의로 느려짐 / timeout
  - 결함을 감지하는 것도 쉽지 않음
  - 결함을 발견했을 때 시스템이 이를 견딜 수 있게 만들기도 쉽지 않음
    - 다른 노드의 도움을 요청하고 정족수를 이루려고 시도하는 프로토콜이 필요하다