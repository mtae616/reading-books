# 일관성과 합의
- 내결함성을 지닌 분산 시스템을 구축하는 데 쓰이는 알고리즘과 프로토콜들을 설명
- 내결함성을 지닌 시스템을 구축하는 가장 좋은 방법
  - 범용 추상화를 찾아 구현하고 애플리케이션에서 이 보장에 의존
  - 트랜잭션
    - 애플리케이션은 충돌이 없고
    - 데이터베이스에 동시 접근하지 않으며
    - 저장 서비스는 완전히 믿을 수 있음
  - 합의
    - 모든 노드가 어떤 것에 동의하게 만드는 것
  - split brain
    - 절단된 네트워크 중 두 노드가 각각 자신을 리더라고 생각하는 상황

## 일관성 보장
- 최종적 일관성
  - db 에 쓰기를 멈추고 불특정 시간 동안 기다리면 결국 모든 읽기 요청이 같은 값을 반환한다
  - 불일치는 일시적이며 결국 스스로 해소한다
  - 매우 약한 보장이며, 언제 복제본이 수렴될지는 모름
  - 시스템 결함(순단...)이 있거나 동시성이 높으 때에만 에지 케이스가 분명히 드러난다

## 선형성
- 최종적 일관성을 지닌 db 에서 두 개의 다른 복제본에 같은 질문을 동시에 하면 다른 응답을 받을 수도 있다
- db 가 복제본이 하나만 있다면 훨씬 단순해진다면 훨씬 단순해진다
- 선형성은 시스템에 복사본이 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산은 원자적인 것처럼 보이게 만드는 것
  - 클라이언트가 쓰기를 성공적으로 완료하자마자 db 를 읽는 모든 클라이언트는 방금 쓰여진 값을 볼 수 있엉 ㅑ한다
  - 뒤쳐진 캐시나 복제본에서 나온 값이 아니라고 보장하는 것
  - 다시 말해 선형성은 최신성 보장이다
- 시스템에 선형성을 부여하는 것은 무엇인까?
  - x (레지스터)
      - 키-값 에서는 키 하나, db 에서는 row 하나, document db 에서는 document 하나
  - 선형성은 레지스터(개별 객체)에 실행되는 읽기와 쓰기에 대한 최신성 보장
  - 선형성은 연산을 트랜잭션으로 묶지 않아서 충돌 구체화 같은 부가적인 수단을 사용하지 않으며
  - 쓰기 스큐 같은 문제를 막지 못한다
- 줄이자면, 어떤 노드든 같은 레코드에 접근하게 하고 cud 이뤄지면 다른 노드들은 최신성을 보장해야 하는  

## 선형성에 기대기
- 잠금과 리더 선출
  - split brain 을 막아야 한다
  - 리더를 선출하는 한가지 방법은 잠금을 사용하는 것
    - 잠금을 어떻게 구현하던지 선형적이어야 한다
    - 모든 노드는 어느 노드가 잠금을 소유하는지에 동의해야 한다
- 제약 조건과 유일성 보장
  - 이 제약 조건을 강제하고 싶을 때에도 선형성이 필요
  - cas 연산과 비슷
  - id, 재고, 좌석
- 채널 간 타이밍 의존성
  - 메세지 큐로 전달하면서 앞의 순번에서 이미 처리해서 예전 버전의 데이터를 보는 것
  - 선형성의 최신성 보장이 없으면 race condition 이 발생할 수 있음

## 선형성 시스템 구현하기
- replication 을 사용하는 것
  - 단일 리더 복제 (선형적)
  - 합의 알고리즘 (선형적)
  - 다중 리더 복제 (비선형적)
  - 리더 없는 복제 (비선형적)

## 선형성과 정족수
- 다이나모 스타일 모델에서는 엄격한 정족수를 사용한 읽기 쓰기는 선형적인 것처럼 보이지만 
- 다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는 게 가장 안전하다

## CAP 정리
- 분산 시스템은 일관성(Consistency), 가용성(Availability 및 분할 내성(Partition tolerance)의 세 가지 원하는 특성 중 두 가지만 제공할 수 있다
- 책에서는 cap 정리는 실용적인 가치가 거의 없다고 설명

## 선형성과 네트워크 지연
- 선형적인 시스템은 매우 드물다
- cpu 의 ram 조차 선형적이지 않다

## 순서화 보장
- 잘 정의된 순서대로 실행된다

## 순서화와 인과성
- 순서화가 인과성을 보존하는 데 도움을 준다뜻
    - 스냅샷 격리에서 트랜잭션이 일관된 스냅샷을 읽는 것은 인과성에 일관적이라는 뜻
- 인과성은 이벤트에 순서를 부과한다
- 인과적 순서가 전체 순서는 아니다
  - 자연수는 전체 순서를 정할 수 있지만 집합은 전체 순서를 정할 수 있는 것은 아니다
    - {a, b} 가 {b, c} 보다 클지 알 수 없다
    - 인과성이 전체 순서가 아닌 부분 순서를 정의한다는 뜻
- 선형성은 일과적 일관성보다 강하다
  - 선형성은 인과성을 내포한다
  - 어떤 시스템이 선형적이라면 인과성도 올바르게 유지한다
- 인과적 의존성 담기
  - 비선형성 시스템이 어떻게 인과적 일관성을 유지할 수 있는지...
    - 연산 순서를 알아야 한다
    - data 에 version vecotr 를 일반화할 수 있어야 한다

## 일련번호 순서화
- 일련번호, 타임스탬프를 써서 이벤트의 순서를 정할 수 있다
  - 이런 방법은 전체 순서를 제공한다
- 비인과적 일련번호 생성기
  - 어느 쪽은 A.I 로 홀수만, 다른 쪽은 짝수만...
  - 일과성에 일관적이지 않다
  - 당연히 어느 쪽이 뒤쳐졌는지 알 수 없음...
- 램포트 타임스탬프
  - 일관적인 일련번호
  - (카운터, 노드ID) 쌍으로 유지
  - 타임스탬프에 노드 ID 를 포함시킨다
  - '20231111000001' 같은 꼴

## 분산 트랜잭션과 합의
- 여러 노드들이 뭔가에 동의하게 만드는 것
  - 리더 선출
  - 원자적 커밋
    - 2pc
- 단일 노드에서 분산 원자적 커밋으로
  - 분산 환경에서 각 노드에서 독립적으로 트랜잭션을 커밋하는 것은 원자성 보장 위반하기 쉽다
- 2pc
  - blocking
- 3pc
  - non-blocking
  - 원자성을 보장하지 못한다

## 현실의 분산 트랜잭션
- 마이sql 의 분산 트랜잭션은 단일 노드 트랜잭션보다 10배 이상 느리다고 보고된다

# 정리
- 일관성과 합의
- 일관성 모델인 선형성
  - 데이터가 오직 하나의 복사본만 있는 것처럼 보이게 하고 데이터에 대한 모든 연산을 원자적으로
  - 느림...
- 광범위한 문제가 실제로는 합의로 환원될 수 있음 (이들 중 하나에 대한 해결책이 있으면 그것을 쉽게 다른 것 중 하나의 해결책으로 변환할 수 있음)
  - 선형성 cas 레지스터
    - 레지스터는 현재 값이 연산의 매개변수로 넘겨진 값과 같은지 여부에 따라 값을 설정할지 말지 원자적으로 결정해야 한다
  - 원자적 트랜잭션 커밋
    - db 는 분산 트랜잭션을 커밋할 것인지 어보트 할 것인지 결정
  - 전체 순서 브로드캐스트
    - 메세징 시스템은 메세지 전달할 순서를 결정해야 한다
  - 잠금과 임차권
    - 잠금 결정
  - 멤버십/코디네이션 서비스
  - 유일성 제약 조건
- 그러나 단일 리더가 장애/순단 시 아무 진행도 못한다 처리하는 방법
  - 리더가 복구될 때까지 기다리고 그동안 차단된 것을 받아드린다
    - xa/jta
  - 사람이 새 리더 노드를 선택해서 수동 장애 복구
  - 자동으로 새 리더를 선택하는 알고리즘