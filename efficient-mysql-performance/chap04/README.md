# 접근 패턴
- MySQL 성능은 애플리케이션에 의해 제한되는 것, 반대는 아니다.
- 데이터 접근 패턴의 중점
  1. 애플리케이션과 별개로 MySQL 이 수행하는 작업과 이것이 중요한 이유
  2. 데이터베이스 성능이 선형으로 확장되지 않는 것을 증명, 대신 성능이 불안정해지는 한계가 있음
  3. 일부는 MySQL 이 뛰어난 성능을 보여주지만 다른 애플리케이션에서는 그렇지 않은지
  4. 데이터 접근 패턴을 열거
  5. 데이터 접근 패턴을 개선, 수정을 위한 변경 사항 제시
  6. 더 좋고 빠른 하드웨어라는 오랜 주제를 다시 살펴봄

## MySQL 은 아무것도 하지 않는다.
- 애플리케이션 유휴 -> MySQL 유휴
  - MySQL 이 느리게 실행되는데 외부 문제가 없다면 원인은 MySQL 을 구동하는 애플리케이션 뿐
- 성능을 저하시키는 요인
  - vacuuming, compacting, ... 모두 MySQL 에 없음
- 쿼리 프로파일 -> 느린 쿼리 뿐만 아니라 MySQL 이 바쁘게 무얼 하고있는지 확인
- 쿼리 경합
  - 쿼리가 다른 쿼리에 영향을 줌 -> 쿼리가 경쟁하고 공유 리소스를 기다릴 때
  - 로우 락, CPU 경합 등
  - 느린 쿼리를 설명할 수 있으므로 쿼리 경합을 알아야 한다.

## 한계에 도달하면 성능이 불안해진다.
- 선형 스케일링
  - 부하가 증가함에 따라 데이터베이스 성능은 시스템 용량 (하드웨어 및 운영 체제의 처리량) 을 100% 사용할 때까지 증가한 다음, 성능이 일정하게 유지됨
  - 이상이지만, 실현될 수 없음
- 현실적으로 데이터베이스 성능의 한계는 시스템 용량의 80 ~ 95%
  - 부하가 한도를 초과하여 증가하면 데이터베이스 성능이 불안정해짐
  - 처리량, 응답 시간, 기타 메트릭은 정상 값에서 현저하게 변동
  - 최고 사용률인 상태에서 일부 쿼리의 성능이 저하되고 최악의 경우 운영 중단 발생
- 부하가 너무 높으면 (애플리케이션에서 요청하는 트랜잭션이 너무 많으면) MySQL 이 불안정해지기도 함
  - 이럴 때에는 애플리케이션에서 트랜잭션 수를 줄이는 방법도...

## 도요타와 페라리
- 다양한 세부 사항에 세심한 주의가 필요

## 데이터 접근 패턴
- 애플리케이션이 MySQL 을 사용하여 데이터에 접근하는 방법
- 읽기 / 쓰기
  - SELECT / INSERT, UPDATE, DELETE
- 처리량
  - 처리량은 성능이 아니다.
    - 테이블 스캔을 수행하고 모든 행을 잠그는 `SELECT ... FOR UPDATE`
- 데이터 수명
  - 10분 동안 100만개의 행을 삽입하는 경우 가장 첫번째 행은 10분이 지나서가 아니라 접근한 마지막 행이라서 가장 오래된 행
  - 이 특성은 작업 세트에 영향을 미치기 때문에 중요
  - 데이터에 접근하지 않으면 오래되어 결국 메모리에서 제거됨
  - InnoDB 는 모든 메모리를 사용하지만 여유 페이지도 유지함
  - 여유 페이지가 하나도 없다면 문제가 악화됨
    - LRU 목록에서 오래된 페이지를 제거해야 함
    - 오래된 페이지가 더티(데이터 변경 사항이 디스크에 유지되지 않은 경우)일 때 disk flush 해야함
    - storage 에서 데이터를 읽는 속도가 느리다는 원래 문제
    - 정리해서, 오래된 데이터를 자주 가져오는 것은 성능에 문제가 있다
- 데이터 모델
  - key - value, graph, document,... 는 mysql 에 적합하지 않음
- 트랜잭션 격리
  - ACID
  - 웬만하면 default 인 repeatable read 를 사용할 것
- 읽기 일관성
  - strong consistency, 읽기가 가장 최신 값
  - eventual consistency, 읽기가 최신 값이 아닐 수 있지만 결국에는 최신 값이 됨
    - replication lag
- 동시성
  - 동시성이 0 이라면 데이터에 접근할 때 동시에 같은 데이터를 읽거나 쓰지 않는다.
  - 높은 동시성은 같은 데이터를 동시에 자주 읽기나 쓰기로 접근하는 것
  - 같은 데이터에 대한 쓰기 동시성이 높을수록 로우 락 경합이 커진다.
    - 로우 락 경합으로 인해 발생하는 응답 시간이 증가해도 허용될 만한 시간이라면 OK
    - lock wait time, 애플리케이션이 처리하고 다시 시도해야하는 쿼리 오류가 발생되면 허용되지 않음
    - 이럴 때에는 동시성을 낮추거나 쓰기 확장을 위한 shard
  - 읽기 접근에 캐시를 얼마나 적용할 수 있는지도
    - 같은 데이터를 높은 동시성으로 읽지만 자주 변경되지 않을 때에는 캐시에 적합
- 행접근
  - 행 접근의 3가지 유형
    - 포인트 접근, point access : 단일 행
    - 범위 접근, range access : 두 값 사이의 정렬된 행
      - gap lock
    - 임의 접근, random access : 임의의 순서로 여러 행
      - gap lock
- 결과 세트
  - 그룹화, 정렬 (group by, order by, limit) 을 최적화

## 애플리케이션 변경
- 코드 변경시 인프라 변경도 불가피
- 코드 감사
  - 데이터베이스에 접근하는 코드 감사
    - 더 이상 필요하지 않은 쿼리
    - 너무 자주 실행되는 쿼리
    - 너무 빠르게나 자주 재실행되는 쿼리
    - 크거나 복잡한 쿼리 - 단순화할 수 있는지 여부
- 오프로드 읽기
  - 오프로드 : 장치 대신 보조 장치에서 처리함으로써 주 장치의 부하를 낮추고 성능을 향상
  - 오프로드 읽기 : 읽기를 소스가 아닌 복제본(또는 cache)에 위임하여 소스는 쓰기, 복제본은 읽기로 운영

## MySQL 복제본
- 프로덕션에서 최소한 1개 이상의 복제본이 있고, 2개 이상의 복제본이 있는 것은 흔한 일
- Read / Write split 은 흔한 일
  - 복제본이 읽기로 사용될 수 있다고 가정하면 다음 3가지 이유로 캐시 서버보다 선호 됨
    - 가용성
    - 유연성
      - 캐시 서버의 CPU 와 메모리는 구성 매개변수에 의해 제한되어 있음
      - 반면에 고가용성을 위해 사용되는 복제본은 소스와 같은 하드웨어를 가져야 하므로 여유 리소스가 있음
    - 단순함
      - 애플리케이션은 복제본을 소스와 동기화 상태로 유지하기 위해 아무것도 할 필요가 없음
      - 캐시를 사용하면 갱신, 무효화, 제거를 관리해야 함
- 캐시 서버
  - 캐시 서버는 SQL, transaction, 지속성 있는 스토리지로 인해 방해받지 않음
  - MySQL 보다 매우 빠르지만 제대로 사용하려면 애플리케이션에서 더 많은 작업이 필요함
  - 캐시 갱신, 무효화, 제거를 관리해야 함
  - key - value 로 관리해야 함
  - 캐싱은 자주 접근하지만 드물게 변경되는 데이터에 적합
    - 애플리케이션이 넣은 내용만 저장하므로
  - 나쁜 예
    - 유닉스 타임스탬프로 관리되는 데이터는 변경 빈도가 높기 떄문에 (접근 빈도가 변경 빈도보다 훨씬 클때에는 예외임)
  - 좋은 예
    - 연단위로 관리되는 데이터 (현재 연도가 초당 한 번만 요청된다면 1QPS 는 데이터 접근에 아무런 영향을 주지 않으므로 캐시는 가치가 없음)
  - 캐시를 사용할 때 주의점은 일시적인지, 지속 가능한지 결정
  - 캐시에 너무 많이 의존하거나 캐시가 너무 커서 재구성이 불가능 할 때에는 지속성이 뛰어난 캐시가 필요함
- 쓰기 대기열에 넣기, queue
  - 쓰기 처리량을 안정화
  - MySQL 가용성에서 애플리케이션을 분리한다는 것
    - MySQL 이 오프라인일 때에도 queue 에 적재 가능
    - 손실되거나 버려진 변경사항을 복구하는 데에 사용될 수도 있음
    - retry 할 수도 있음
- 데이터 분할
  - partitioning 
    - 접근별로 파티션을 나누고 핫 데이터 / 콜드 데이터를 분리
    - 자주 접근하지 않는 데이터를 자주 접근하는 데이터의 접근 경로 밖으로 옮겨 보관
  - 콜드 데이터를 분리했을 때의 이점
    - 더 많은 핫 데이터가 메모리에 올라감
    - 쿼리가 콜드 데이터를 검사하는 데 시간을 낭비하지 않음
    - 작업 (e.g. schema change) 가 더 빠름
    - 콜드 데이터를 `insert ... select` 로 옮길 수 있음, 그런 다음 delete
- mysql 을 사용하지 않기
  - key-value, graph, document, ...

## 더 좋고 빠른 하드웨어
- 하드웨어를 확장해야 하는 정확한 시점?
- 점검 표
  - 모두 체크
    - 응답 시간이 너무 길다
    - 느린 쿼리가 최적화 되어 있다
    - 데이터가 삭제 또는 보관되어 있다
    - 접근 패턴을 검토하고 최적화 했다.
  - 적어도 2개 이상 체크
    - CPU 사용율 80% 이상
    - 실행 중인 스레드가 CPU 코어 수보다 많다.
    - 메모리가 전체 데이터 크기의 10% 미만
    - 스토리지 IOPS 사용율이 80% 이상
- 읽기 집약 / 쓰기 집약적인지에 따라 추가 고려 필요
  - 읽기 집약
    - 지속적으로 IOPS 가 높은 것은 메모리 부족때문일 수도 있음
    - 메모리에 없을 대 디스크에서 읽으며 작업 세트를 메모리에 보관
      - 그러나 작업 세트가 메모리보다 훨씬 크고 읽기 처리량이 유난히 높다는 2가지 요인이 결합하면 읽기 IOPS 가 높아질 수 있다.
  - 쓰기 집약
    - 스토리지가 데이터를 원하는 만큼 빠르게 쓸 수 없다.
    - 일반적으로 스토리지는 쓰기 캐시로 높은 처리량을 달성하지만 캐시는 지속성이 떨어짐
    - 캐시가 아닌 지속성 있는 스토리지에 flush 하여 디스크에 강제로 기록해야 함

## 정리
- MySQL 은 애플리케이션 쿼리만 실행하고 그 외에는 아무것도 하지 않는다.
- 데이터베이스 성능은 하드웨어 용량의 100% 에 다다를 때 불안정해진다
- 일부 애플리케이션은 모든 세부 사항이 고성능에 맞추어 설계되엇으므로 MySQL 성능에서 훨씬 뒤어나다
- 접근 패턴은 애플리케이션이 MySQL 을 사용하여 데이터에 접근하는 방법이다
- 데이터 접근 패턴을 변경하려면 애플리케이션을 변경해야 한다.
- 다른 해결 방법을 최대한 적용해본 후 하드웨어 확장을 통해 성능을 향상시킨다.
- 참고
  - IOPS : Input / Output Operations Per Second, 초당 입출력 작업 횟수, Disk IO