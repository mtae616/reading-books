# 트랜잭션

## 로우 락
- row lock 말고도 별개의 락이 있음
  - gap lock, next key lock, ...
- 레코드와 넥스트-키 락
  - phantom read 를 방지
  - 조건으로 선택된 레코드를 읽을 때, 다른 트랜잭션이 새로운 레코드를 삽입하는 것을 방지
  - e.g. `SELECT * FROM t WHERE i > 10 FOR UPDATE;` 를 실행하고 있는 도중에 다른 트랜잭션이 `INSERT INTO t VALUES (11);` 를 실행하면 phantom read 가 발생
  - 따라서 10 이상인 `i` 에 next key lock 을 걸어서 삽입을 방지
    - 만약 10 이 마지막 레코드였다면 10 이상인 레코드는 next key lock (supermum pseudo-record) 를 걸기 때문에 삽입하지 못함
  - supermum pseudo-record 를 사용하여 phantom read 를 방지
    - <a href="https://medium.com/daangn/mysql-gap-lock-%EB%91%90%EB%B2%88%EC%A7%B8-%EC%9D%B4%EC%95%BC%EA%B8%B0-49727c005084">참고</a>
    - REAPEATABLE-READ 는 검색하고 스캔했던 인덱스 레코드를 잠근다는 규칙
    - 만약 위의 쿼리 중, i 가 11 이상인 레코드를 읽었다면, 11 이상인 레코드에 next key lock 을 걸어서 삽입을 방지
- 갭 락
  - 갭에 행을 삽입하는 것을 방지
- 세컨더리 인덱스
  - 인덱스 선택도가 낮을수록 레코드 갭이 커진다.
  - 중복된 값이 많을 수록 넥스트 키 락이 많이 걸림. => 성능 저하
- 삽입 의도 잠금 insert intention lock
  - 갭이 다른 트랜잭션에 의해 잠기지 않을 때 트랜잭션이 갭에 행을 삽입함을 의미하는 갭 락
  - insert intention lock 은 미래의 작업을 나타내므로 갭을 잠그지 않는다, 다른 트랜잭션이 보유한 갭 락이 없을 때 행을 삽입
  - insert intention lock 은 다른 트랜잭션이 보유한 갭 락과 충돌할 때만 생성되고 보고된다, 그렇지 않으면 행을 삽입하는 트랜잭션에서 삽입 의도 잠금이 생성되거나 보고되지 않는다.
  - insert intention lock 이 생성되면 한 번 사용하고 한 번 허용되면 즉시 해제된다, 그러나 InnoDB 는 트랜잭션이 완료될 때까지 계속 보고한다.
- InnoDB 는 명시적 잠금만을 보고한다.
  - 명시적 잠근은 메모리에 잠금 구조로 존재한다. (암시적 잠근은 존재하지 않는다, 각주 : 메모리에 없다는 뜻인듯)
  - 만약 `insert into elem values (...)` 쿼리를 실행하고 commit 하지 않는다면 
    - 위의 쿼리는 새 행에 대한 인덱스 레코드가 존재하지만 행이 커밋 되지 않았다.
    - 다른 트랜잭션이 행을 잠그려고 하면 다음 3가지 조건을 감지한다.
      1. 행이 커밋되지 않음
      2. 행이 다른 트랜잭션에 속해 있음
      3. 행이 명시적으로 잠겨있지 않음
    - 요청 트랜잭션은 소유 트랜잭션(insert 쿼리 실행) 을 대신하여 암시적 잠금을 명시적 잠금으로 변환
      - <a href="https://liltdevs.tistory.com/192">참고</a>
        - 위의 예시에서도 처음에는 IX 락만 걸려있었는데, 다른 thread 에서 같은 pk 의 x lock (insert) 하려고 하니까 락 잡힘
        - thread 3501 이 3개임

## MVCC 와 언두 로그
- MVCC + undo 로 ACI 를 구현 (D 를 달성하기 위해 InnoDB 는 transaction log 를 사용)
  - MVCC 는 행에 대한 변경 사항이 행의 새 버전을 생성
  - 버전 2에서 변경 사항을 롤백하기 위해 버전 1을 복원

## 변경 내역 목록 길이, History List length
- HLL
  - 롤백 세그먼트
    - 언두 슬록
      - 언두 로그 세그먼트
        - 언두 로그
          - 언두 로그 기록
- 쿼리 응답 시간을 낮출 수 있지만 동시성을 위한 약간의 성능 저하
- HLL 이 10만 보다 큰 경우 조치를 취해야 하긴 함

## 일반적인 문제
- 대규모 트랜잭션 (트랜잭션 크기)
  - 트랜잭션이 과도한 수의 행을 수정한다는 기준
    - 50만개의 행이 있고 하나의 트랜잭션이 25만개의 행을 수정한다면 과도함
  - 트랜잭션은 작을 수록 좋다
- 오래 실행되는 트랜잭션
  - 오래걸리는 기준
    - 애플리케이션 또는 사용자에게 허용되는 것보다 더 길다
    - 다른 트랜잭션과 문제 (경합) 을 일으킬 만큼 충분히 길다
    - 변경 내역 목록 길이 경고를 발생시킬 만큼 충분히 길다
  - 오래 실행되는 트랜잭션의 2가지 원인
    - 트랜잭션을 구성하는 쿼리가 너무 느리다
    - 애플리케이션이 트랜잭션에서 너무 많은 쿼리를 실행한다.
- 지연된 트랜잭션
  - begin / commit 사이에 대기하는 쿼리
- 버려진 트랜잭션
  - 활성 클라이언트 연결이 없는 활성 트랜잭션, 2가지 요인
    - 애플리케이션 연결 누수
    - 반쯤 닫힌 연결