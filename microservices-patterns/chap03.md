## 마이크로서비스 아키텍처 IPC 개요
- HTTP 기반 REST
- gRPC
- AMQP, STOMP
  - 비동기 메시지 기반 통신
- TEXT 기반, Binary 기반 포멧

## 3.1.1 상호 작용 스타일
1. 일대일
   - 일대일 : 각 클라이언트 요청은 정확히 한 서비스가 처리
     - 동기식 요청/응답
     - 비동기식 용청/응답
     - 단방향 알림 : 클라이언트는 서비스에 일방적으로 요청만 하고 응답을 보내지 않는다.
   - 일대다 : 각 클라이언트 요청을 여러 서비스가 협동하여 처리
     - 발행/구독 : 클라이언트는 알림 메시지를 발행하고, 여기에 관심있는 0개 이상의 서비스(즉, 관심 있는 서비스가 없는 경우도 있음)가 메시지를 소비
     - 발행/비동기 응답 : 클라이언트는 요청 메시지를 발행하고 주어진 시간 동안 관련 서비스가 응답하길 기다림
2. 동기/비동기
   - 동기 : 클라이언트는 서비스가 제시간에 응답하리라 기대하고 대기 도중 블로킹
   - 비동기 : 클라이언트가 블로킹 하지 않음, 응답은 즉시 전성되지 않아도 됨

## 3.1.2 마이크로서비스 API 정의
- MSA 에서는 API 와 인터페이스가 똑같이 중요
  - 서비스 API 는 서비스와 클라이언트 간의 약속
  - 클라이언트가 호출 가능한 작업과 서비스가 발행하는 이벤트로 구성
  - 작업에는 이름, 매개변수, 반환형이 있음
  - 타입과 필드를 가진 이벤트는 메시지 채널에 발행
- 어떤 IPC 를 선택하든 서비스 API 를 IDL(인터페이스 정의 언어)로 정확하게 정의해야 함
  - 반드시 API 를 먼저 설계해라!

## 3.1.3 API 발전시키기
- 모놀리식은 API 를 수정하는 게 어렵지 않음
- MSA 는 클라이언트를 다른 서비스 팀이 개발한 경우가 대부분이기 때문에 서비스 API 를 변경하기가 무척 어려움
  - 서비스를 사용하는 클라이언트를 강제로 업그레이드 시킬 수 없음

### 시멘트 버저닝
- semantic versioning specification
  - API 버저닝에 관한 유용한 지침서
  - MAJOR : 하위 호환되지 않는 변경분을 API 적용 시
  - MINOR : 하위 호환되는 변경분을 API 에 적용 시
  - PATCH : 하위 호환되는 오류 수정 시
- 하위 호환되는 소규모 변경
  - 옵션 속성 추가, 속성 응답 추가, 새 작업 추가
  - "당신이 하는 일은 보수적으로, 다른 사람들이 하는 일은 관대하게"
- 중대한 대규모 변경
  - 일정 기간 동안 서비스는 신, 구 버전 API 모두 지원

## 3.1.4 메시지 포맷
- IPC 핵심
- 범언어적 메시지 포맷을 선택하는 것이 중요
  - 자바 직렬화는 자바에 국한된 기술이므로 사용하지 않음
- 텍스트 메시지 포맷
  - JSON, XML
  - 메시지 컨슈머는 자신이 관심 있는 값만 골라 쓰고 나머지는 무시하면 되므로 하위 호환성 쉽게 보장
- 이진 메시지 포맷
  - 포맷
    - 프로토콜 버퍼
    - 아브로

## 3.2 동기 RPI 패턴 응용 통신
- RPI 는 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회신하는 IPC

## 3.2.1 동기 RPI 패턴 : REST
- REST 는 HTTP 로 소통하는 IPC
  - resource 는 REST 의 핵심 개념
    - 비즈니스 객체들
  - REST 는 HTTP 동사를 활용해서 URL 로 참조되는 리소스를 가공
  - GET 요청은 XML 문서나 JSON 객체 포맷으로 리소스 표현형 반환
  - POST 새 리소스 생성
  - PUT 기존 리소스 업데이트

### REST 성숙도 모델
- 레벨 0
  - URL endpoint 에 POST 요청하여 서비스 호출
  - 요청할 때마다 어떤 액션을 수행할지 대상은 무엇인지 지정
- 레벨 1
  - 리소스 개념 지원
  - 클라이언트는 수행할 액션과 매개변수가 지정된 POST 요청 함
- 레벨 2
  - HTTP 동사를 이용해서 액션 수행
  - 요청 쿼리 매개변수 및 본문, 필요시 매개변수 지정
- 레벨 3
  - 서비스를 HATEOAS 원칙에 기반하여 설계

### REST API
- API 는 I이 fh wjddmlgodi gksek.
  - swagger

### 요청 한 번으로 많은 리소스를 가져오기 어렵다
- REST 리소스는 비즈니스 객체 중심
  - 연관된 객체 모두 가져올 수 있을지에 대한 고민이 생김

### 작업을 HTTP 동사에 매핑하기 어렵다
- endpoint 이름 짓기 어려움

### REST 장단점
- 장점
  - 단순하고 익숙하다
  - postman, curl, 같은 도구들로 간단하게 테스트
  - 요청/응답 스타일의 통신 지원
  - HTTP 는 방화벽 친화적
  - 중간 브로커가 필요하지 않음
- 단점
  - 요청/응답 스타일의 통신만 지원
  - 가용성이 떨어진다.
    - 중간 메세지 버퍼링하는 매개자 없이 직접 통신하기 때문에 양쪽 다 실행해야 함
  - endpoint 를 클라이언트가 알고있어야 함
  - 요청 한 번으로 여러 리소스를 가져오기 어렵다

### 동기 RPI 패턴 : gRPC
- gRPC -> 다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크
- 이진 메시지 기반의 프로토콜 (IDL 로 설계할 수 밖에 없다.)
- 프로토콜 버퍼 기반의 IDL 로 정의
  - 이진 포맷
  - 각 필드마다 번호가 매겨지고 타입 코드가 할당됨
  - 메시지 수신자는 자신이 필요한 필드만 추출하고 모르는 필드는 그냥 건너뛸 수 있기 때문에 하위 호환성을 유지하며 API 발전 가능
  - 프로토콜 버퍼 컴파일러로 클라이언트 쪽 스텁 및 서버 쪽 스켈레톤을 생성할 수 있음
  - 이 컴파일러를 이용하면 자바, C#, Node.js, Go 등 다양한 언어의 코드를 생성
- 클라이언트/서버는 프로토콜 버퍼 포맷의 이진 메시지를 HTTP/2 를 통해 교환
- gRPC API 는 하나 이상의 서비스와 용청/응답 메시지 데피니션으로 구성

## 3.2.3 부분 실패 처리: 회로 차단기(circuit breaker) 패턴
- 클라이언트는 응답 대기 도중 블로킹되기 때문에 서비스 실패는 클라이언트의 클라이언트로 거슬러 올라가면서 전체 시스템의 중단을 초래할 수 있음
- 따라서 부분 실패가 애플리케이션 전체에 전파되지 않도록 서비스 설계해야 함
  - 무응답 원격 서비스를 처리하기 위해 견고한 RPI 프록시를 설계한다.
  - 원격 서비스가 실패하면 어떻게 조치해야 할지 결정한다.

### 견고한 RPI 프록시 설계
- 네트워크 타임 아웃
- 미처리 요청 개수 제한
  - 미처리 요청의 최대 개수를 제한한다.
- 회로 차단기 패턴
  - 성공/실패 요청 개수를 지켜보다가 에러율이 주어진 임계치를 초과하면 바로 실패 처리

### 불능 서비스 복구

## 3.2.4 서비스 디스커버리
- 서비스 IP 주소가 정적으로 구성된 클라이언트 대신 서비스 디스커버리 메커니즘 사용
  - 서비스 인스턴스의 네트워크 위치를 db화 한 서비스 레지스트리
  - 서비스 인스턴스가 시작/종료할 때마다 서비스 레지스트리 업데이트
  - 클라이언트가 서비스를 호출하면 서비스 레지스트리에서 가용 서비스 인스턴스 목록을 가져오고 그 중 하나로 라우팅
  - 구현 방법
    - 클라이언트/서비스가 직접 서비스 레지스트리와 상호 작용
    - 배포 인프라로 처리

### 애플리케이션 수준의 서비스 디스커버리 패턴 적용
- 클라이언트/서비스가 직접 서비스 레지스트리와 상호 작용하는 방법
- 자신의 위치를 서비스 레지스트리에 등록하고 클라이언트는 목록을 가져와 한 곳에 라우팅

### 플랫폼에 내장된 서비스 디스커버리 패턴 적용
- <a href="https://thebook.io/007035/0158/">참고</a>
- 서드파티 등록 패턴
  - 서비스가 자신을 서비스 레지스트리에 등록하는 것이 아니라 배포 플랫폼의 일부인 등록기(registrar) 라는 서드파티가 대행함
- 서버 쪽 디스커버리 패턴
  - 클라이언트가 서비스 레지스트리에 질의하지 않고 DNS 명을 요청, 서비스 레지스트리를 쿼리하고 요청을 부하 분산하는 요청 라우터로 해석됨

## 3.3 비동기 메시징 패턴 응용 통신
- 비동기적으로 주고받는 통신 방식
  - 메시지 브로커 사용
  - 서비스가 직접 서로 통신하는 브로커리스 아키텍처

### 3.3.1 메시징 개요
- 메시지는 메시지 채널을 통해 교환
- 송신자가 채널에 메시지를 쓰면 수신자가 읽음

### 메시지
- 헤더/바디
  - 헤더 -> 메타 데이터
  - 본문 -> 텍스트/이진 데이터
- 메시지 종류
  - 문서
    - 데이터만 포함된 제네릭한 메시지, 메시지를 어떻게 해석할지 수신자가 결정
  - 커맨드
    - RPC 요청과 동등한 메시지
    - 호출할 작업과 전달할 매개변수가 지정되어 있음
  - 이벤트
    - 송신자에게 어떤 사건이 발생했음을 알리는 메시지

### 메시지 채널
- 종류
  - 점대점 채널
    - 채널을 읽는 컨슈머 중 딱 하나만 지정해서 전달
    - 커맨드
  - 발행-구독 채널
    - 같은 채널을 바라보는 모든 컨슈머에 메시지 전달
    - 이벤트

### 3.3.2 메시징 상호 작용 스타일 구현
- 요청/응답 및 비동기 요청/응답
  - 메시징은 성격 자체가 비동기적
  - 메시지의 요청/응답은 messageId 를 지정해서 구별한다.
- 단방향 알림
  - 점대점 채널에 메시지를 보내면 처리한다.
- 발행/구독
- 발행/비동기 응답
  - 발행/구독 + 요청/응답
  - 발행/구독 채널에 발행하고 응답 메시지를 지정된 응답 채널에 쓴다.

### 3.3.3 메시징 기반 서비스의 API 명세 작성
- <a href="https://thebook.io/007035/0170/">참고</a>
- REST, Open API 와 달리 자유롭게 기술하면 된다.
- 비동기 작업 문서화
  - 요청/비동기 응답 스타일 API
    - 서비스의 커맨드 메시지 채널 서비스가 받는 커맨드 메시지의 타입과 포맷 서비스가 반환하는 응답 메시지의 타입과 포맷
  - 단방향 알림 스타일 API
    - 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷으로 구성
- 발행 이벤트 문서화
  - 이벤트 채널, 서비스가 채널에 발행하는 이벤트 메시지의 타입과 포맷

### 3.3.4 메시지 브로커
- 서비스가 서로 통신할 수 있게 하는 인프라 서비스
- 브로커리스 메시징
  - 메시지를 직접 교환
  - 장점
    - 송신자가 보낸 메시지가 브로커를 거쳐 수신자로 이동하는 것이 아니라 송신자에게 수신자로 직접 전달되므로 네트워크 트래픽이 가볍고 지연 시간이 짧다.
    - 메시지 브로커가 성능 병목점이나 SPOF(단일 장애점) 가 될 일이 없다.
    - 메시지 브로커를 설정/관리할 필요가 없으므로 운영 복잡도가 낮다.
  - 단점
    - 서비스가 서로의 위치를 알고 있어야 하므로 서비스 디스커버리 매커니즘 중 하나를 사용해야 한다.
    - 메시지 교환 시 송신자/수신자 모두 실행 중이어야 하므로 가용성이 떨어진다.
    - 전달 보장 같은 메커니즘을 구현하기가 더 어렵다.
- 브로커 기반 메시징 개요
  - 제품
    - ActiveMQ
    - RabbitMQ
    - Kafka
  - 메시지 브로커로 메시지 채널 구현
    - <a href="https://thebook.io/007035/0177/">참고</a>
  - 장점
    - 느슨한 결합
      - 채널에만 보냄
    - 메세지 버퍼링
      - 처리 가능한 시점까지 메세지를 버퍼링
      - 컨슈머가 처리할 수 있을 때까지 큐에 메세지를 쌓음
      - 에러가 발생해도 컨슈머는 주문을 계속 접수할 수 있음
    - 유연한 통신
    - 명시적 IPC
  - 단점
    - 성능 병목 가능성
      - 메세지 브로커가 병목점이 될 수 있음
    - 단일 장애점 가능성
    - 운영 복잡도 증가.

## 3.3.5 수신자 경합과 메세지 순서 유지
- 주문 생성 - 주문 변경 - 주문 취소가 순서대로 가야 하는데, 하나의 채널을 읽는 와스가 3개면 문제가 됨
  - 샤딩된 채널을 이용
  - orderId 를 샤드 키로 두고, 주문별 이벤트는 각각 동일한 샤드에 발행되고 어느 한 컨슈머 인스턴스만 메시지를 읽기 때문에 처리 순서가 보장된다.
  1. 샤딩된 채널은 복수의 샤드로 구성되며 각 샤드는 채널처럼 작동
  2. 송신자는 메시지 헤더에 샤드 키를 지정, 메시지 브로커는 메세지를 샤드 키별도 샤드/파티션에 배정
     a. 예를 들어 샤드 키 해시 값을 샤드 개수로 나눈 나머지를 계산해서 샤드를 선택
  3. 메세징 브로커는 여러 수신자 인스턴스를 묶어 마치 동일한 논리 수신자처럼 취급, 메시지 브로커는 각 샤드를 하나의 수신자에게 배정하고 수신자가 시동/종료하면 샤드를 재배정

## 3.3.6 중복 메시지 처리
- 클라이언트/네트워크/브로커가 실패할 경우 같은 메시지를 여러 번 절달할 수도 있음
  - 에러에 의해서
  - 방법
    - 멱등한 메시지 핸들러 작성
    - 메시지 추적하고 중복을 솎아 낸다.
  - 멱등한 메시지 핸들러 작성
    - 실제로 별로 없다.
  - 메시지 추적과 중복 메시지 솎아 내기
    - 컨슈머가 메시지 ID 를 이용하여 메시지 처리 여부를 추적하고 소비하는 메시지 ID 를 DB 에 저장
    - 중복된 메시지라면 ID 를 저장하는 insert query 가 실패함

## 3.3.7 트랜잭셔널 메시징
- 현대 메시지 브로커는 분산 트랜잭션을 지원하지 않는다.
- DB 테이블을 메시지 큐로 활용
  - 로컬 DB(OUTBOX)에 쓰고 다른 서비스에서 읽게 해서 메시지로 발행한다. (로컬 ACID 보장)
- 이벤트 발행 : 폴링 발행기 패턴
  - 주기적으로 outbox 테이블을 폴링해서 메시지 발행
  - 메시지를 발행하면 row 지움
- 이벤트 발행 : 트랜잭션 로그 테일링 패턴
  - DB 트랜잭션 로그를 테일링 하는 방법
  - 개발 공수가 제법 소요됨

## 3.4 비동기 메시징으로 가용성 개선

## 3.4.1 동기 통신으로 인한 가용성 저하
- blocking...

## 3.4.2 동기 상호 작용 제거
- 모든 트랜잭션을 비동기 상호 작용으로 처리하는 것이 좋음
- 비동기 상호 작용 스타일
  - 메세징 큐로 주고 받으면서 비동기를 유지
- 데이터 복제
  - 데이터가 변경 될 때 업데이트된 상태 값을 서비스에서 들고 있음
  - 동기적 작용이 있을 때 blocking 되는 것을 막기 위해
  - 실용적이진 않음
- 응답 반환 후 마무리
  - 동기 통신을 제거하려면 다음과 같이 하면 된다.
  1. 로컬에서 가용한 데이터만 갖고 요청을 검증
  2. 메시지를 outbox 테이블에 삽입하는 식으로 db 업데이트
  3. 클라이언트에 응답 반환
  - <a href="https://thebook.io/007035/0202/">참고</a>