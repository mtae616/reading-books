# 트랜잭션 관리 - 사가
- 기존 분산 트랜잭션 관리 기법이 요즘 애플리케이션에 잘 맞지 않음
- ACID 트랜잭션 대신 사가라는 메시지 주도 방식의 로컬 트랜잭션을 사용
  - ACD 만 지원

## 4.1 마이크로서비스 아키텍처에서의 트랜잭션 관리
- 하나의 디비 트랜잭션으로 처리 - @Transactional
  - 단일 DB에 접근하는 모놀리식 애플리케이션의 트랜잭션 관리는 어렵지 않음

## 4.1.1 분산 트랜잭션의 필요성
- MSA 는 트랜잭션이 복잡한
- 서비스마다 DB 따로 있기 때문에 일관성을 유지할 수 있는 수단을 강구

## 4.1.2 분산 트랜잭션의 문제점
- X/Open DTP 모델 (XA) 는 분산 트랜잭션의 사실 표준
  - 2PC 를 이용하여 전체 트랜잭션 참여자가 반드시 커밋 아니면 롤백 하도록 보장
  - XA 호환 기술 스택
    - XA 호환 DB
    - 메시지 브로커
    - DB 드라이버
    - 메시징 API
    - XA 전역 트랜잭션 ID 를 전파하는 프로세스 간 매커니즘
  - SQL DB 대부분, 메시지 브로커 일부 제품 호환
  - JTA 기술을 이용하여 분산 트랜잭션 수행
- 문제점
  - NoSQL, 메시지 브로(RabbitMQ, Kafka) 지원 안 함
  - 동기 IPC 형태라 가용성 떨어짐
  - CAP 정리
    - 일관성 consistency
    - 가용성 availability
    - 분할 허용성 partition tolerance
    - 중 2가지 속성만 가질 수 있음
    - 최근엔 일관성보다 가용성을 더 우선시 하는 편
    - 일관성을 위해 SAGA 를 쓴다.

## 4.1.3 데이터 일관성 유지: 사가 패턴
- 사가는 비동기 메시징을 이용하여 편성한 일련의 로컬 트랜잭션
  - 서비스 간 데이터 일관성은 사가로 유지한다.
  - 서비스는 로컬 트랜잭션이 완료되면 메시지를 발행하여 다음 사가 단계를 트리거한다.
  - 메시지를 통해 사가 참여자를 느슨하게 결합하고 사가가 반드시 완료되도록 보장
  - 메시지 수신자가 일시 불능 상태라면 메시지 브로커는 다시 메시지를 전달할 수 있을 때까지 메시지를 버퍼링
- 사가와 ACID 트랜잭션의 차이점
  - ACID 트랜잭션에 있는 격리성이 사가에는 없다.
  - 사가는 로컬 트랜잭션마다 변경분을 커밋하므로 보상 트랜잭션을 걸어 롤백해야 한다.
- 사가는 보상 트랜잭션으로 변경분을 롤백한다.
  - ACID 는 언두를 롤백
  - 사가는 단계마다 로컬 DB에 변경분을 커밋하므로 자동 롤백은 불가
  - 가령 4단계에서 실패하면 1 ~ 3 번째 단계에서 적용된 변경분을 명시적으로 언두해야 한다.
    - 즉 보상 트랜잭션을 미리 작성해야 한다.
    - 읽기 전용 같은 단계는 필요하지 않음
  - 주문을 예로 들면
    1. 주문 서비스 : 주문을 APPROVAL_PENDING 상태로 생성
    2. 소비자 서비스 : 소비자가 주문을 할 수 있는지 확인합니다.
    3. 주방 서비스 : 주문 내역을 확인하고 티켓을 CREATE_PENDING 상태로 생성합니다.
    4. 회계 서비스 : 소비자의 신용카드 승인 요청이 거부됩니다.
    5. 주방 서비스 : 티켓 상태를 CREATE_REJECTED 로 변경합니다.
    6. 주문 서비스 : 주문 상태를 REJECTED 로 변경합니다.

## 4.2 사가 편성
- 사가는 단계를 편성하는 로직으로 구성
- 편성 로직은 첫 번째 사가 참여자를 정하여 로컬 트랜잭션 실행을 지시하고 트랜잭션이 완료되면 그다음 사가 참여자를 호출하는 과정이 모든 단계가 실행될 때까지 반복
- 도중 하나라도 로컬 트랜잭션이 실패하면 사가는 보상 트랜잭션을 역순으로 실행
- 편성 로직 2종류
  - 코레오그래피
    - 의사 결정과 순서화를 사가 참여자에게 맡김.
    - 사가 참여자는 주로 이벤트 교환 방식으로 통신함.
  - 오케스트레이션
    - 사가 편성 로직을 사가 오케스트레이터에 중앙화함
    - 사가 오케스트레이터는 사가 참여자에게 커맨드 메시지를 보내 수행할 작업을 지시함

## 4.2.1 코레오그래피 사가
- 중앙 편성자 없이 사가 참여자가 서로 이벤트를 구독해서 반응
- 주문 생성 사가 구현 : 코레오그래피 스타일
  - 서로 이벤트를 주고 받으며 소통
  1. 주문 서비스 : 주문을 APPROVAL_PENDING 상태로 생성 -> 주문 생성 이벤트를 발행
  2. 소비자 서비스 : 주문 생성 이벤트 수신 -> 소비자가 주문을 할 수 있는지 확인 -> 소비자 확인 이벤트 발행
  3. 주방 서비스 : 주문 생성 이벤트 수신 -> 주문 내역 확인 -> 티켓을 CREATE_PENDING 상태로 생성 -> 티켓 생성됨 이벤트를 발행
  4. 회계 서비스 : 주문 생성 이벤트 수신 -> 신용카드 승인을 PENDING 상태로 생성
  5. 회계 서비스 : 티켓 생성 및 소비자 확인 이벤트 수신 -> 소비자 신용카드 과금 -> 신용카드 승인됨 이벤트를 발행
  6. 주방 서비스 : 신용카드 승인 이벤트 수신 -> 티켓 상태를 AWATING_ACCEPTANCE 로 변경
  7. 주문 서비스 : 신용카드 승인됨 이벤트 수신 -> 주문 상태를 APPROVED 로 변경 -> 주문 승인됨 이벤트를 발행
  - 만약 위의 케이스가 거절된 경우
  1. 주문 서비스 : 주문을 APPROVAL_PENDING 상태로 생성 -> 주문 생성 이벤트를 발행
  2. 소비자 서비스 : 주문 생성 이벤트 수신 -> 소비자가 주문을 할 수 있는지 확인 -> 소비자 확인 이벤트를 발행
  3. 주방 서비스 : 주문 생성 이벤트 수신 -> 주문 내역 확인 -> 티켓을 CREATE_PENDING 상태로 생성 -> 티켓 생성됨 이벤트를 발행
  4. 회계 서비스 : 주문 생성 이벤트 수신 -> 신용카드 승인을 PENDING 상태로 생성
  5. 회계 서비스 : 티켓 생성 및 소비자 확인 이벤트 수신 -> 소비자 신용카드 과금 -> 신용카드 승인 실패 이벤트 발행
  6. 주방 서비스 : 신용카드 승인 실패 이벤트 수신 -> 티켓 상태를 REJECTED 로 변경
  7. 주문 서비스 : 신용카드 승인 실패 이벤트 수신 -> 주문 상태를 REJECTED 로 변경
- 확실한 이벤트 기반 통신
  - 코레오그래피 방식 사가 2가지 통신 이슈
    - 사가 참여자가 자신의 DB 를 업데이트 하고 DB 트랜잭션의 일부로 이벤트를 발행하도록 해야 함
      - 이떄 업데이트와 이벤트 발행이 원자적으로 발생해야 함
    - 자신이 수신한 이벤트와 자신이 가진 데이터를 연관 지을 수 있어야 한다.
      - 신용카드 승인됨 이벤트를 받은 주문 서비스는 여기서 해당 주문을 찾을 수 있어야 함
      - 다른 사가 참여자가 상관관계 ID 가 포함된 이벤트를 발행해야 함
- 코레오그래피 사가의 장단점
  - 장점
    - 단순함
      - 비즈니스 객체를 생성, 수정, 삭제할 때 서비스가 이벤트를 발행
    - 느슨한 결합
      - 참여자는 이벤트를 구독할 뿐 서로를 직접 알지 못합니다.
  - 단점
    - 이해하기 어려움
      - 서비스에 구현 로직이 흩어져 있음
    - 서비스 간 순한 의존성
    - 단단히 결합될 위험성
      - 사가 참여자끼리 이벤트를 모두 구독

## 4.2.2 오케스트레이션 사가
- 사가 참여자가 할 일을 알려주는 오케스트레이터 클래스를 정의
- 사가 오케스트레이터는 커맨드/비동기 응답 상호 작용을 하며 참여자와 통신
  - 즉 해당 참여자가 무슨 일ㅇ르 해야 하는지 커맨드 메세지에 적어 보냄
  - 사가 참여자가 응답을 오케스트레이터에 주면 오케스트레이터는 응답 메세지를 처리한 후 다음 단계를 어느 참여자가 수행할지 결정함
- 주문 서비스 예시
  1. 사가 오케스트레이터가 소비자 확인 커맨드를 소비자 서비스에 전송
  2. 소비자 서비스는 소비자 확인 메시지를 응답
  3. 사가 오케스트레이터는 티켓 생성 커맨드를 주방 서비스에 전송
  4. 주방 서비스는 티켓 생성 메시지를 응답
  5. 사가 오케스트레이터는 신용카드 승인 메시지를 회계 서비스에 전송
  6. 회계 서비스는 신용카드 승인됨 메시지를 응답
  7. 사가 오케스트레이터는 티켓 승인 커맨드를 주방 서비스에 전송
  8. 사가 오케스트레이터는 주문 승인 커맨드를 주문 서비스에 전송
- 사가 오케스트레이터를 상태 기계로 모델링
  - <a href="https://thebook.io/007035/0229/">참고</a>
- 장점
  - 의존 관계 단순화
    - 오케스트레이터는 참여자를 호출하지만 참여자는 오케스트레이터를 호출하지 않아 순환 의존성이 발생하지 않음
  - 낮은 결합도
  - 관심사를 더 분리하고 비즈니스 로직을 단순화
    - 사가 편성 로직이 사가 오케스트레이터 한 곳에만 있으므로
- 아주 단순한 사가가 아니라면 가급적 오케스트레이션 방식을 권장한다.

## 4.3 비격리 문제 해결
- 격리성
  - 여러 트랜잭션의 결과가 어떤 순서대로 실행된 결과와 동일함을 보장하는 속성
- 사가는 격리성이 빠져있음
  - 한 트랜잭션이 커밋한 변경분을 다른 사가가 즉시 바라볼 수 있음
  - 한 사가가 실행 중에 접근하는 데이터를 도중에 다른 사가가 바꿔치기 할 수 있음
  - 한 사가가 업데이트를 하기 전에 데이터를 다른 사가가 읽을 수 있어서 데이터 일관성이 깨질 수 있음
- 사가의 ACD
  - Atomicity : 사가는 트랜잭션을 모두 완료하거나 모든 변경분을 언두해야 한다.
  - Consistency : 서비스 내부의 참조 무결성은 로컬 DB 가 여러 서비스에 걸친 참조 무결성은 서비스가 처리함.
  - Durability : 로컬 DB 로 처리함.

## 4.3.1 비정상 개요
- 비격리로 인한 비정상
  - 소실된 업데이트
    - 한 사가의 변경분을 다른 사가가 미처 못 읽고 덮어 쓴다.
  - 더티 읽기
    - 사가 업데이트를 하지 않은 변경분을 다른 트랜잭션이나 사가가 읽는다.
  - 퍼지/반복 불가능한 읽기
    - 한 사가의 상이한 두 단계가 같은 데이터를 읽어도 결과가 달라지는 현상
    - 다른 사가가 그 사이 업데이트를 했기 때문에 생기는 문제

## 4.3.2 비격리 대책
- 시맨틱 락
  - 애플리케이션 수준의 락
- 교환적 업데이트
  - 업데이트 작업은 어떤 순서로 실행해도 되게끔 설계
- 비관적 관점
  - 사가 단계 순서를 재조정하여 비즈니스 리스크 최소화
- 값 다시 읽기
  - 데이터를 덮어 쓸 때 그 전에 변경된 내용은 없는지 값을 다시 읽고 확인하여 더티 쓰기를 방지
- 버전 파일
  - 순서를 재조정할 수 있게 업데이트를 기록
- 값에 의한
  - 요청별 비즈니스 위험성을 기준으로 동시성 매커니즘을 동적 선택
- 사가의 구조
  - 사가를 구성하는 트랜잭션
    - 보상 가능 트랜잭션 : 보상 트랜잭션으로 롤백 가능한 트랜잭션
    - 피봇 트랜잭션 : 사가의 진행/중단 지점
    - 재시도 가능 트랜잭션 : 피봇 트랜잭션 직후의 트랜잭션, 반드시 성공
- 대책 : 시맨틱 락
  - 레코드에 무조건 플래그를 셋팅
  - 레코드에 락을 걸어 놓거나 경고 할 수 있음
  - 플래그는 재시도 가능 트랜잭션(사가 완료) 또는 보상 트랜잭션(사가 롤백)에 의해 해제됨
- 대책 : 교환적 업데이트
  - 업데이트를 교환적으로 즉 어떤 순서로도 가능하게 설계하는 소실된 업데이트 문제를 방지할 수 있음
- 대책 : 비관적 관점
  - 더티 읽기로 인한 비즈니스 리스크 최소화하기 위해 사가 단계의 순서를 재조정
- 대책 : 값 다시 읽기
  - 낙관적 락 패턴
  - 다시 읽어서 데이터가 변경되었으면 재시도
- 대책 : 버전 파일
  - 레코드에 수행한 작업을 기록하는 방법

