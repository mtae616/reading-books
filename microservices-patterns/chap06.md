# 비즈니스 로직 개발 : 이벤트 소싱

## 6.1 이벤트 소싱 응용 비즈니스 로직 개발
- 이벤트 소싱 : 상태 변화를 나타내는 일련의 도메인 이벤트로 애그리거트를 저장한다.
- 이벤트 소싱은 비즈니스 로직을 구성하고 애그리거트를 저장하는 또 다른 방법
- 애그리거트를 일련의 이벤트 형태로 저장
- 이벤트는 각 애그리거트의 상태 변화를 나타냄
- 애플리케이션은 이벤트를 재연하여 애그리거트의 현재 상태를 재생성함

## 6.1.1 기존 영속화의 문제점
- order (1) : OrderLineItem(N)
  - 위의 관계는 단점이 있음
  - 객체-관계 임핃던스 부정합
    - 테이블 형태의 관계형 스키마와 관계가 복잡한 리치 도메인 모델의 그래프 구조는 근본적인 개념부터 다름
    - db 스키마랑 도메인 간의 관계는 다르다
  - 애그리거트 이력이 없다.
    - 현재 애그리거트의 상태만 저장
    - 이전 상태는 남아있지 않음
  - 감사 로깅은 구현하기 힘들고 오류도 자주 발생
  - 이벤트 발행 로직이 비즈니스 로직에 추가된다.

## 6.1.2 이벤트 소싱 개요
- 이벤트를 위주로 비즈니스 로직 구현, 애그리거트를 DB 에 일련의 이벤트로 저장하는 기법
- 이벤트를 이용하여 애그리거트를 저장
  - order 애그리거트를 events 테이블에 여러 로우로 저장한다
  - 애그리거트를 로드할 때 이벤트 저장소에서 이벤트를 가져와 재연한다.
    1. 애그리거트의 이벤트를 로드
    2. 기본 생성자를 호출하여 애그리거트 인스턴스 생성
    3. 이벤트를 하나씩 순회하며 apply 호출
- 이벤트는 곧 상태 변화
  - 도메인 이벤트는 애그리거트의 변경을 구독자에게 알리는 장치
  - 이벤트는 애그리거트 ID 같은 최소한의 필수 데이터만 넣거나 컨슈머에 유용한 데이터까지 포함시켜 강화할 수 있다.
  - 애그리거트의 상태 변화를 도메인 이벤트로 나타내므로 이벤트가 필수적
  - 이벤트는 애그리거트가 상태 전이를 하기 위해 필요한 데이터를 갖고 있어야 한다.
- 애그리거트 메서드의 관심사는 오직 이벤트
  - 이벤트 소싱을 사용하면 커맨드 메서드가 반드시 이벤트를 발생시킴

## 6.1.3 동시 업데이트: 낙관적 잠금
- version 으로 관리

## 6.1.4 이벤트 소싱과 이벤트 발행
- 이벤트 소싱은 애그리거트를 여러 이벤트로 저장하여 현재 상태로 다시 구성
- 아래는 이벤트 발행하는 방법
- 이벤트 발행: 폴링
  - 이벤트 발행기가 특정 테이블을 select 하면서 계속 폴링하여 발행
  - 그러나 트랜잭션이 이벤트를 발생시키는 순서와 다르게 커밋할 수도 있음, 이벤트를 건너뛸 수도 있다.
  - 플래그 주면 해결됨..
- 이벤트 발행: 트랜잭션 로그 테일링

## 6.1.5 스냅샷으로 성능 개선
- 주기적으로 스냅샷을 생성해놓음
- 스냅샷을 사용할 경우 애그리거트 인스턴스는 기본 생성자가 아닌 스냅샷을 이용하여 재생성

## 6.1.6 멱등한 메시지 처리
- 여러 번 호출해도 안전해야 한다.
- ID 채번

## 6.1.7 도메인 이벤트 발전시키기
- 가장 흔히 사용하는 변경 처리 방법
- 이벤트 스키마
  - 스키마
    - 하나 이상의 애그리거트로 구성
    - 각 애그리거트가 발생시키는 이벤트를 정의
    - 이벤트 구조를 정의
- 업캐스팅을 통한 스키마 변화 관리

## 6.1.8 이벤트 소싱의 장점
- 도메인 이벤트를 확실하게 발행한다.
  - 애그리거트 상태가 변경될 때마다 확실하게 발행한다.
- 애그리거트 이력이 보존된다.
  - 전체 이력이 그대로 보존되고 과거 상태를 쉽게 조회할 수 있다.
- O/R 임피던스 불일치 문제를 대부분 방지한다.
  - 서비스는 과거 상태를 죽 나열해서 복잡한 애그리거트의 스냅샷을 뜰 수 있다.
- 개발자에게 타임 머신을 제공한다.

## 6.1.9 이벤트 소싱의 단점
- 새로운 프로그래밍 모델을 배우는 데 시간이 걸린다.
- 메시징 기반 애플리케이션은 복잡하다
- 이벤트를 개량하기가 까다로운 편
- 데이터를 삭제하기가 어렵다
- 이벤트 저장소를 쿼리하기가 만만찮다.