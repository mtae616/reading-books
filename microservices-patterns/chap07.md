# 마이크로서비스 쿼리 구현
- 분산된 데이터를 어떻게 조회하는가
- API 조합 패턴
  - 여러 서비스를 직접 호출하여 조합
- CQRS 패턴
  - 쿼리만 지원하는 하나 이상의 뷰 전용 DB 를 유지하는 패턴

## 7.1 API 조합 패턴 응용 쿼리

## 7.1.2 API 조합 패턴 개요
- API 조합기
  - 프로바이더 서비스를 쿼리하여 데이터를 조회
- 프로바이더 서비스
  - 최종 결과로 반환할 데이터의 일부를 갖고 있는 서비스

## 7.1.4 API 조합 설계 이슈
- 어느 컴포넌트를 쿼리 잡업의 API 조합기로 선정?
  1. 서비스 클라이언트(웹 애플리케이션)를 API 조합기로 임명한다.
  2. 애플리케이션의 외부 API 가 구현된 API 게이트웨이를 API 조합기로 만든다.
  3. API 조합기를 스탠드 얼론 서비스로 구현
- 어떻게 해야 효율적으로 취합 로직을 작성?
- API 조합기는 리액티브 프로그래밍 모델을 사용해야 한다.

## 7.1.5 API 조합 패턴의 장단점
- 장점
  - 아주 쉽고 간단하게 쿼리 작업
- 단점
  - 오버헤드 증가
  - 가용성 저하 우려
    - 가용성 증가 2가지 방법
      - 캐싱
      - 미완성된 데이터를 반환(...?)
  - 데이터 일관성 결여

## 7.2 CQRS 패턴
- RDBMS 특유의 트랜잭션 기능 + 텍스트 검색 DB 탁월한 쿼리 능력
- CQRS 는 위와 같은 종류의 아키텍처를 일반화한 것
- 하나 이상의 쿼리가 구현된 하나 이상의 뷰 DB 를 유지한다.

## 7.2.1 CQRS 의 필요성
- API 조합은 효율적으로 구현하기 어려운 다중 서비스 쿼리가 많다
  - 다른 서버 API 에서 제공하지 않는 데이터가 필요한 경우 등...(정렬, 컬럼, ...)
- 관심사를 분리할 필요가 있음

## 7.2.2 CQRS 개요
- API 를 조합하여 여러 서비스에 흩어진 데이터를 조회하려면 값비싸고 비효율적인 인-메모리 조인을 해야 한다.
- 데이터를 가진 서비스는 필요한 쿼리를 효율적으로 지원하지 않는 DB에, 또는 그런 형태로 데이터를 저장한다.
- 관심사를 분리할 필요가 있다는 것은 데이터를 가진 서비스가 쿼리 작업을 구현할 장소로 적합하지 않다는 뜻이다.
- CQRS 는 커맨드와 쿼리를 서로 분리한다.
  - 영속적 데이터 모델과 그것을 사용하는 모듈을 커맨드와 쿼리로 나눈다.
  - CUD 는 커맨드 쪽 모듈 및 데이터 모델에 구현
  - 양쪽 데이터 모델 사이의 동기화는 커맨드 쪽에서 발행한 이벤트를 쿼리 쪽에서 구독하는 식으로 이뤄진다.
- CQRS 와 쿼리 전용 서비스
  - 커맨드 작업이 전혀 없이 다른 서비스가 발행한 이벤트를 구독하여 항상 최신 상태로 유지되는 DB 를 쿼리하는 로직을 구현
  - 특정 서비스에 종속되지 않기 때문에 스탠드 얼론 서비스로 구현하는 것이 타당

## 7.2.3 CQRS 의 장점
- 마이크로서비스 아키텍처에서 쿼리를 효율적으로 구현할 수 있다.
- 다양한 쿼리를 효율적으로 구현할 수 있다.
- 이벤트 소싱 애플리케이션에서 쿼리가 가능하다.
- 관심사가 더 분리된다.

## 7.2.4 CQRS 의 단점
- 아키텍처가 더 복잡하다
- 복제 시차, Replication lag 을 처리해야 한다.
  - 커맨드 이벤트를 발행 -> 쿼리 적용 하는 지연

## 7.3 CQRS 뷰 설계
- DB 를 선정하고 스키마를 설계
- 데이터를 접근 모듈을 설계할 때 멱등한/동시 업데이트 등 다양한 문제를 고려
- 기존 애플리케이션에 새 뷰를 구현하거나 기존 스키마를 바꿀 경우, 뷰를 효율적으로 빌드할 수 있는 수단 강구
- 뷰 클라이언트에서 복제 시차를 어떻게 처리할지 결정

## 7.3.1 뷰 DB 선택
- SQL vs NoSQL

| ~가 필요하면           | ~를 사용한다                                   | 예시                           |
|-------------------|-------------------------------------------|------------------------------|
| JSON 객체를 pk 로 검색  | 문서형 스토어(mongo, Dynamo), key-value (redis) | 고객별 mongoDB 문서로 주문 이력 관리     |
| 쿼리 기반의 JSON 객체 검색 | 문서형 스토어                                   | mongo, dynamo 로 고객 뷰 구현      |
| 텍스트 쿼리 | 텍스트 검색 엔진 (일래스틱 서치)                       | 주문별 일래스틱 서치 문서로 주문 텍스트 검색 구현 |
| 그래프 쿼리 | 그래프 db(neo4j)                             | 고객, 주문, 기타 데이터의 그래프          |
| 전통적인 SQL | rdbms                                     | 표준 비즈니스 리포트 및 분석             |

- 업데이트 작업 지원
  - 이벤트 핸들러가 실행할 업데이트 작업 또한 효율적으로 수행해야 한다
  - fk 를 사용할 경우 NoSQL 은 쉽지 않음

## 7.3.2 데이터 접근 모듈 설계
- DAO 는 이벤트 핸들러가 호출한 업데이트 작업과 쿼리 모듈이 호출한 쿼리 작업을 실질적으로 수행
- 동시성 처리
  - 한 종류의 애그리거트가 발행한 이벤트를 구독한다면 동시성 이슈는 없다 -> 순차적 처리되기 때문에
  - 여러 종류라면 발생함
- 멱등한 이벤트 핸들러
  - 이벤트의 상태에 대한 멱등성을 유지해야됨
- 클라이언트 애플리케이션이 최종 일관된 뷰를 사용할 수 있다

## 7.3.3 CQRS 뷰 추가 및 업데이트
- 아카이빙 된 에빈트를 사용
- CQRS 뷰를 단계적으로 구축

## 정리
- 각 서비스 데이터를 private -> 여러 서비스의 데이터를 가져오는 쿼리는 구현하기 쉽지 않다.
- API 조합, CQRS
- API 조합이 가장 간편함
- API 조합은 대량 데이터를 in-memory 조인 해야되기 때문에 효율이 낮음
- CQRS 패턴은 뷰 전용 DB 를 이용하여 쿼리 -> 복잡도 높음
- CQRS 뷰 모듈은 중복 이벤트 솎아 내기 동시 업데이트 처리 기능을 갖춰야 함
- CQRS 를 사용하면 한 서비스가 다른 서비스가 소유한 데이터를 반환하는 쿼리 구현도 가능하므로 관심사 분리 관점에서 유리
- 클라이언트는 CQRS 뷰의 최종 일관성을 처리해야 한다.