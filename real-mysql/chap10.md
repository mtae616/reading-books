# 실행 계획

- dbms 가 항상 좋은 실행 계획을 만들어 내는 것은 아님
- 따라서 사용자가 보완할 수 있게 explain 으로 확인

## 통계 정보

- 8.0 부터 인덱스되지 않은 컬럼에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보 도입
- **테이블 및 인덱스 통계 정보**
    - 통계 정보가 정확하지 않다면 엉뚱한 방향으로 쿼리를 실행할 수 있다.
    - `MySQL 서버의 통계 정보`
        - stats_persistent 옵션을 통해 통계 정보를 영구적으로 관리할 수 있게 한다.
        - 아래 두 테이블로 관리한다.
            - innodb_index_stats
                - stat_name
                    - n_diff_pfx% : 유니크한 값의 개수
                    - n_leaf_pages : 리프 노드 페이지 개수
                    - size : 인데스 페이지 개수
                - n_rows : 테이블의 전체 레코드 건수
                - clustered_index_size : 프라이머리 키 크기
                - sum_of_other_index_size : 프라이머리 키를 제외한 인덱스 크기
            - innodb_table_stats
        - innodb_stats_transient_sample_pages
            - 기본값 8 → 통계 정보 수집 실행될 때 8개 페이지만 임의로 샘플링해서 분석
        - innodb_stats_persistent_sample_pages
            - 기본값 20 → 임의로 20개 페이지만 샘플링해서 분석하고 영구적인 통계 정보 테이블에 저장 및 활용
- **히스토그램**
    - 데이터 분포도를 참조할 수 있는 히스토그램 정보
    - `히스토그램 정보 수집 및 삭제`
        - 칼럼 단위 히스토그램 정보 관리
            - ANALYZE TABLE … UPDATE HITOGRAM 명령을 통해 수동으로 관리
            - 정보는 시스템 딕셔너리에 저장되고 서버 시작될 때 히스토그램 정보를 information_schema db 의 column_statistics 테이블로 로드 → column_statistics 에서 정보 확인 가능
            - singleton 싱글톤 히스토그램
                - 컬럼값 개별로 레코드 건수를 관리하는 히스토그램, (= value-based, 도수 분포도)
            - equi-height 높이 균형 히스토그램
                - 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램 (= height-balanced)
    - `히스토그램의 용도`
        - 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않으므로 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다
            - 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측한다.
            - 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.
            - 각 칼럼에 대해 히스토그램 정보가 있으면 어느 테이블을 먼저 읽어야 조인의 횟수를 줄일 수 있을지 옵티마이저가 정확하게 판단할 수 있다.
    - `히스토그램과 인덱스`
        - 히스토그램과 인덱스는 완전히 다르지만 통계 정보를 수집하기 위해 사용된다는 공통점이 있다.
        - MySQL 서버는 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.
            - 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B Tree 를 샘플링해서 살펴본다. (인덱스 다이브)
            - 인덱스된 컬럼을 검색 조건으로 사용하는 경우 칼럼의 히스토그램은 사용하지 않고 인덱스 다이브를 통해 정보를 활용한다.
            - 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.
    - `코스트 모델`
        - 전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용 → 코스트 모델
        - 쿼리를 처리하기 위한 작업들
            - 디스크로부터 데이터 페이지 읽기
            - 메모리(InnoDB 버퍼 풀)로 부터 데이터 페이지 읽기
            - 인덱스 키 비교
            - 레코드 평가
            - 메모리 임시 테이블 작업
            - 디스크 임시 테이블 작업
        - 코스트 모델 설정값
            - server_cost
                - 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
            - engine_cost
                - 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리
                - engine_name
                    - 비용이 적용된 스토리지 엔진
                - device_type
                    - 디스크 타입
            - 공통으로 갖는 컬럼
                - cost_name
                    - 각 단위 작업
                - default_value
                    - 각 단위 작업의 비용
                - cost_value
                    - DBMS 관리자가 설정한 값
                - last_updated
                    - 단위 작업의 비용이 변경된 시점
                - comment
                    - 설명
        - 기본값 유지하는 것을 권장

## 실행 계획 확인

- desc 또는 explain 으로 확인
- **실행 계획 출력 포맷**
    - format 옵션을 통해 json, tree, 단순 테이블 형태로 볼 수 있음
- **쿼리의 실행 시간 확인**
    - 쿼리의 실행 계획과 소요된 시간 정보를 확인할 수 있는 explain analyze 기능이 추가 됨
    - 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
    - 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행

## 실행 계획 분석

- explain 으로 나오는 실행 계획이 어떤 접근 방법을 사용해서 어떤 최적화를 수행하는지, 어떤 인덱스를 사용하는지 등을 이해하는 것이 더 중요하다.

- 표에서는 사용된 테이블 만큼 행으로 표시됨
- 실행순서는 위에서 아래로 순서대로 표시된다
    - 위 쪽에 출력된 결과일수록 쿼리의 바깥 부분이거나 먼저 접근
- **id 칼럼**
    - id 컬럼은 단위(SELECT) 쿼리 별로 부여되는 식별자
    - select 문장은 하나인데 여러개의 테이블이 조인되는 경우는 id 값이 증가하지 않고 같은 id 값이 부여된다.
        - 실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지는 않음을 주의
- select_type 컬럼
    - select 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼
    - `SIMPLE`
        - 단순 select 쿼리
        - 쿼리 문장이 아무리 복잡해도 실행 계획에서 select_type 이 simple 인 단위 쿼리는 하나만 존재한다.
        - 일반적으로 제일 바깥 select 쿼리
    - `PRIMARY`
        - UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리는 select_tyupe 이 primary 로 표시 됨
    - `UNION`
        - UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 select 쿼리의 select_type 은 UNION 으로 표시됨
    - `DEPENDENT UNION`
        - UNION 또는 UNION ALL 로 결합하는 쿼리가 외부 커리에 의해 영향을 받을 때 내부 쿼리에 DEPENDENT UNION 으로 표시된다.
            - IN, OR …etc
    - `UNION RESULT`
        - UNION 결과를 담아두는 테이블
        - UNION ALL 의 경우 임시 테이블을 사용하지 않고 UNION(UNION DISTINCT)는 여전히 임시 테이블에 결과를 버퍼링한다.
    - `SUBQUERY`
        - from 절 이외에서 사용되는 서브 쿼리
            - from 절에 사용되는 서브쿼리는 DERIVED 로 표시
    - `DEPENDENT SUBQUERY`
        - 서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경우
        - 안쪽 서브쿼리가 바깥쪽에 의존적이기 때문에 일반 서브쿼리보다는 처리 속도가 느릴 때가 많다
    - `DERIVED`
        - from 절에서 서브쿼리가 사용되면서 단위 select 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 경우
            - 쿼리를 튜닝하기 위해 실행 계획의 DERIVED 가 있는지 확인한다
            - 서브쿼리를 조인으로 해결할 수 있다면 서브쿼리 보다 조인을 권장한다.
    - `DEPENDENT DERIVED`
        - FROM 절 서브쿼리에서 외부 칼럼을 참조할 때
    - `UNCACHEABLE SUBQUERY`
        - 하나의 쿼리 문장에 조건이 똑같은 서브쿼리가 실행될 때는 이전의 실행 결과를 그대로 캐시 공간에 담아두어 재사용된다.
        - 그러나 서브쿼리에 포함된 요소에 의해 캐시 자체가 불가능 할 수 있는데 이 때 UNCACHEABLE SUBQUERY 로 표시된다.
            - 사용자 변수가 서브쿼리에 사용된 경우
            - NOT-DETERMINISTIC 속성이 스토어드 루틴이 서브쿼리 내에 사용된 경우
            - UUID() 나 RAND() 와 같이 결과값이 호출할 때마다 달라지는 함수가 서브쿼리에 사용되는 경우
    - `UNCACHEBLE UNION`
        - UNION + UNCACHEABLE
    - `MATERIALIZED`
        - from 절이나 in 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용
        - 서브 쿼리의 내용을 임시 테이블로 구체화(materialization) 한 후 임시 테이블과 실제 테이블을 조인하는 형태로 최적화되어 처리된다.
- **table 칼럼**
    - 서버의 실행 계획은 단위 select 쿼리 기준이 아니라 테이블 기준으로 표시된다.
    - table 칼럼에 <> 으로 둘러싸인 이름이 명시되는 경우 이 테이블이 임시 테이블이다.
    - <> 안에 숫자는 select 쿼리의 id 를 지칭한다.

    - 위의 실행 계획 분석
        - 첫 번째 라인의 테이블이 <derived2> 라는 것으로 보아 이 라인보다 id 값이 2인 라인이 먼저 실행되고 그 결과가 파생 테이블로 준비돼야 한다는 것을 알 수 있다.
        - 세번째 라인(id 값이 2인 라인)을 보면 select_type 칼럼의 값이 derived 로 표시돼 있다 즉, 이 라인은 table 칼럼에 표시된 dept_emp 테이블을 읽어서 파생 테이블을 생성했다는 것을 알 수 있다.
        - 세번째 라인의 분석이 끝났으므로 다시 실행 계획의 첫 번째로 돌아간다.
        - 첫 번째 라인과 두 번째 라인의 id 가 같은 것은 서로 조인 됨을 추측할 수 있고 1번 라인의 테이블이 표시되었으므로 <derived2> 가 드라이빙 테이블, e 가 드리븐 테이블이 된다.
- **partition 컬럼**
    - 8.0 부터 explain 명령으로 파티션 관련 실행 계획까지 모두 확인 가능

    - 위와 같은 테이블을 생성했다고 가정하고,
        - hire_date 를 5년 단위로 파티션을 나눈다.
        - 파티션 관련 제약사항 : 파티션키로 사용되는 칼럼은 프라이머리 키를 포함한 모든 유니크 인덱스의 일부여야 한다.

    - 파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 파티션 프루닝 (partition pruning) 이라 한다
    - 파티션을 참조하는 쿼리(파티션 키 칼럼을 where 조건으로 가진)의 경우 옵티마이저가 쿼리 처리를 위해 필요한 파티션들의 목록만 모아서 실행 계획의 partitions 칼럼에 표시해준다.

    - 위의 실행 계획에서 type 칼럼 값이 ALL 로 표시되는데 이는 풀 테이블 스캔으로 처리 됨을 의미한다.
        - 파티션은 물리적으로 개별 테이블 저장 공간을 가진다. 따라서 각 파티션의 풀 테이블 스캔을 실행한다.
- **type 칼럼**
    - type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지 나타낸다.
        - 인덱스를 사용하여 읽었는지 풀 테이블 스캔으로 읽었는지
    - type 컬럼은 실행계획에서 각 테이블의 접근 방법을 나타낸다.
        - 인덱스를 효율적으로 사용하는지 확인하기 위해 type 칼럼은 반드시 체크해야할 중요 정보
    - 앞으로 설명할 12개 방법 중 ALL 을 제외하면 index 를 사용하는 방법
        - ALL 은 table full scan
    - 아래의 순서는 빠른 순서로 나열
    - `system`
        - 레코드가 1건 or 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근방법
        - InnoDB 스토리지 엔진에서는 나타나지 않는다.
    - `const`
        - 테이블의 레코드 건수와 관계없이 쿼리가 PK, Unique 칼럼을 이용하는 where 조건 절
        - 반드시 1건을 반환하는 쿼리의 처리 방식
            - UNIQUE INDEX SCAN이라고도 표현한다.
        - 프라이머리 키 일부 조건만 사용할 때에는 ref 로 표시된다.
        - MySQL 옵티마이저는 const type 쿼리를 통째로 상수화 → const
    - `eq_ref`
        - 여러 테이블이 조인되는 쿼리의 실행 계획에서 조인에서 처음 읽은 테이블의 칼럼값을, 그 다음 읽어야할 테이블의 pk, unique key 칼럼 검색 조건에 사용할 때를 eq_ref 라고 한다
            - 두번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방식
            - 이 때 두번째 이후에 읽는 테이블의 type 칼럼에 eq_ref 가 표시된다.
        - 다음과 같은 상황을 가정하자
            - 첫째 라인과 둘째 라인의 id 값이 1로 같으므로 두 테이블이 조인으로 실행된다.
            - dept_emp 테이블이 위에 있으니 dept_emp 테이블을 먼저 읽고 e.empt_no = de_emp_no 조건을 이용해 employees 테이블을 검색한다.
            - employees 테이블의 키가 emp_no 이므로 두번째 라인의 type 칼럼이 eq_ref 로 표시된다.

    - `ref`
        - 인덱스의 종류와 관계없이 동등(equal) 조건으로 검색할 때 ref 접근 방법이 이용 된다.
        - ref 타입은 반한되는 레코드가 반드시 1건이라는 보장이 없으므로 const, eq_ref 보다는 빠르지 않다.

        ```sql
        explain
        select * from dept_emp where dept_no = 'd005';
        ```

        - dept_emp 테이블의 pk (dept_no, emp_no) 라 할 때 일부만 동등 조건으로 명시됐지 때문에 조건에 일치하는 레코드가 1건이라는 보장이 없다.
            - 따라서 const 대신 ref 접근 방법이 사용되었다.
    - `fulltext`
        - MySQL 서버의 전문 검색(Full-text Search) 인덱스를 사용해 레코드를 직접 읽는 방식
        - 쿼리에서 전문 인덱스를 사용하는 조건과 그 이외의 인덱스를 사용하는 조건을 함께 사용하면 일반 인덱스의 접근 방법이 const, eq_ref, ref 가 아니면 일반적으로 MySQL 옵티마이저는 전문 인덱스를 사용하는 조건을 선택한다.
    - `ref_or_null`
        - ref 과 같은데 nulldl cnrkehls gudxo
        - ref 방식 또는 null 비교(is null) 접근 방법을 의미

    - `unique_subquery`
        - where 조건 절에서 사용되는 IN(subquery) 형태의 쿼리를 위한 접근 방법
            - unique_subquery 의미 그대로 중복되지 않는 유니크한 값만 반환할 때 사용

    - `index_subquery`
        - IN(subquery) 또는 IN(상수 나열) 형태의 조건에서 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있을 때 이 접근 방법을 사용
            - 위의 unique_subquery 와의 차이는 중복된 값이 있는지 여부
    - `range`
        - 인덱스 레인지 스캔
        - range 는 인덱스를 하나의 값이 아니라 범위로 검색하는 겨우를 의미
        - 주로 “<, >, IS NULL, BETWEEN, IN, LIKE” 등의 연산자를 이용해 인덱스를 검색할 때 사용
        - range 접근 방법도 상당히 빠르고 최적의 성능 보장

    - `index_merge`
        - 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어 낸 후 그 결과를 병합해서 처리하는 방식
        - 특징
            - 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방법보다 효율성이 떨어진다.
            - 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge 가 적용되지 않는다.
            - index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합 또는 중복 제거와 같은 부가작업이 필요하다.

    - `index`
        - index 풀 스캔
        - 테이블 풀 스캔과 비교했을 때 레코드 수는 같지만 인덱스의 크기가 작으므로 비교적 빠르게 처리되고, 정렬된 인덱스의 장점을 활용할 수 있어 효율적
    - `ALL`
        - 테이블 풀 스캔
        - 가장 마지막에 선택하는 비효율 적인 방법
        - 풀 테이블 스캔이나 인덱스 풀 스캔시 한꺼번에 많은 페이지를 읽어 들이는 리드 어헤드 기능을 제공
        - 일반적으로 index 와 ALL 접근 방법은 작업 범위를 제한하는 조건이 아니므로 빠른 응답을 보내는 웹서비스나 온라인 트랜잭션 처리 환경에는 적합하지 않다.
- **possible_keys 칼럼**
    - 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 인덱스의 목록
    - 실제 실행 계획에서 이 칼럼에 모든 인덱스가 포함되는 경우가 많아서 크게 도움이 되지 않는 컬럼
        - 무시해도 좋다.
        - 이 칼럼에 나온다고 인덱스를 사용했다고 판단하지 말자
- **key 칼럼**
    - key 칼럼에 표시되는 인덱스는 최종 실행 계획에서 사용하는 인덱스
    - 쿼리를 튜닝할 때는 이 칼럼에 의도했던 인덱스가 나오는지 확인하는 것이 중요
        - PRIMARY 또는 인덱스 이름으로 표시도니다.
- **key_len 칼럼**
    - 다중 칼럼으로 만들어진 인덱스에서 쿼리를 처리하기 위해 몇개의 칼럼이 사용됐는지를 판단할 때 사용되는 칼럼
        - 중요한 컬럼 중 하나
        - 바이트 단위로 표시

    - 위의 쿼리에서 프라이머리 키는 (dept_no, emp_no) rntjd
    - dept_no 칼럼의 타임이 char(4) 이기 때문에 프라이머리 키에서 앞쪽 16바이트만 유효하게 사용했다는 의미이다.
        - utf8mb4 문자 집합에서 문자 하나가 차지하는 공간이 1 - 4 바이트로 가변적이지만 MySQL 서버에서 메모리 공간을 할당해야 할 때는 고정 4바이트로 계산
        - 따라서 16바이트가 표시되었다.

    - 위의 쿼리는 dept_no 와 emp_no 각각의 조건을 가지고 있다.
    - dept_emp 테이블의 emp_no 칼럼 타입이 INTEGER 일때 4바이트를 차지하므로 위의 쿼리는 dept_no, emp_no 를 사용함을 알 수있다.
- **ref 칼럼**
    - 접근 방법이 ref, eq_ref 일 때 참조 조건(where 절의 동등비교)로 어떤 값이 제공됐는지 보여준다.
        - 크게 신경쓰지 않아도 되는 컬럼
    - 컬럼의 이름이나, 산술 조건 표현식을 넣으면 func 로 표시되는 것을 볼 수 있다.
        - MySQL 내부적으로 값을 변환해야 할 때도 func 가 출력
- **rows 칼럼**
    - 가능한 처리 방식이 얼마나 많은 레코드를 읽고 비교해야 하는지 예측해서 비용을 산정
    - rows 칼럼값은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.
        - 이 값은 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라서 정확하지는 않다.
        - 이 값은 반환하는 레코드를 예측한 수가 아니라 쿼리를 처리하기 위해 체크한 레코드 수를 의미한다.
        - 그래서 실행 계획의 rows 컬럼에 출력되는 값과 실제 쿼리 결과 반환된 레코드 건수는 일치하지 않는 경우가 많다.
- **filtered 칼럼**
    - 각 테이블에서 일치하는 레코드 개수를 가능하면 정확히 파악해야 더 효율적인 실행계획을 수립할 수 있다.
    - 특히나 조인을 사용할 때 일치하는 레코드 수가 적은 테이블이 드라이빙 테이블로 선정되어야 하는데 이 때 rows 칼럼 * filtered 칼럼의 결과로 비교한다.
        - filtered 칼럼 값은 필터링 되고 남은 레코드의 비율을 의미한다.
- **Extra 칼럼**
    - Extra 칼럼에는 성능에 관련된 중요한 내용
    - 내부적인 처리 알고리즘에 대해 조금 더 깊이있는 내용을 보여주는 경우가 많다.
    - `const row not found`
        - const 접근 방법으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1 건도 존재하지 않을 때 표시된다.
    - `Deleting all rows`
        - where 조건 절이 없는 delete 문장의 실행 계획에서 자주 표시된다.
    - `Distinct`
        - Distinct 키워드를 사용했을 때 표시된다.
    - `FirstMatch`
        - 세미 조인의 FirstMatch 전략을 사용한다면 FirstMatch(table_name) 메시지를 출력한다.
        - 함계 표시되는 테이블명은 기준 테이블을 의미한다.
    - `Full scan on NULL key`
        - col1 IN (SELECT col2 FROM … ) 과 같은 조건을 가진 쿼리에서 col1 의 값이 NULL 이면 표시된다.
    - `Impossible Having`
        - Having 절의 조건을 만족하는 레코드가 없을 때
            - 쿼리 점검 요망
    - `Impossible Where`
        - Where 조건이 항상 False 가 될 수 밖에 없을 때
    - `LooseScan`
        - 세미조인의 Loose scan 최적화 전략이 사용될 때
    - `No matching min/max row`
        - MIN, MAX 와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때
    - `no matching row in const table`
        - 조인에 사용된 테이블에서 const 방법으로 접근할 때 일치하는 레코드가 없는 경우
    - `no matching rows aafter partition pruning`
        - 해당 파티션에서 UPDATE 하거나 DELETE 할 대상 레코드가 없을 때
    - `no tables used`
        - FROM 절이 없는 쿼리 문장이나 FROM DUAL 형태의 쿼리를 실행할 경우
    - `no exists`
        - A 테이블에는 존재하지만 B 테이블에는 없는 값을 조회해야 하는 경우
            - 주로 NOT IN(subquery) 형태나 NOT EXISTS 연산자를 사용한다.
        - 이를 outer 조인으로 처리하면 빠른 성능을 낼 수 있다.(쿼리가 어려움)
            - 아우터 조인을 이용해서 안티 조인을 수행하는 쿼리에서 Not exists 메시지가 표시된다.
    - `Plan isn;t ready yet`
        - 다른 커넥션에서 실행중인 쿼리의 실행 계획을 살펴볼 때 쿼리의 실행 계획을 수립하지 못한 상태에서 조회 시에 위와 같이 표시된다.
    - `Range checked for each record(index map;N)`
        - 아래의 쿼리와 같이 레코드마다 인덱스 레인지 스캔을 하게 되는 경우
        - 괄호 안의 index map; N 은 인덱스를 사용할지 말지 판단하게 되는 인덱스를 의미

        ```sql
        EXPALIN
        SELECT *
        FROM employees e1, employees e2
        WHERE e2.emp_no >= e1.emp_no
        ```

    - `Recursive`
        - 재귀 쿼리
    - `Rematerialize`
        - 래터럴 조인으로 조인되는 테이블은 선행 테이블의 레코드별로 서브 쿼리를 실행해서 그 결과를 임시 테이블에 저장한다.
    - `select tables optimized away`
        - min 또는 max 만 select 절에 사용되거나 group by 로 min, max 를 조회하는 쿼리가 인덱스를 오름차순 또는 내림차순으로 1건만 읽는 최적화가 적용될 때
    - `start temporary, end temporary`
        - 세미 조인 최적화 중에서 duplicate weed-out 최적화 전략이 사용될 때
    - `unique row not found`
        - 두개의 테이블이 각각 유니크 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을 대
    - `Using filesort`
        - order by 처리를 인덱스로 할 수 없을 때 레코드를 조회하고 메모리 버퍼에 복사해 정렬을 하게 된다.
    - `Using index`
        - 커버링 인덱스
    - `Using index condition`
        - 인덱스 컨디션 푸시 다운 최적화를 사용할 때
    - `Using index for group-by`
        - 타이트 인덱스 스캔을 통한 group by 처리
        - 루스 인덱스 스캔을 통한 group by 처리
    - `Using index for skip scan`
        - index skip scan
    - `Using join buffer(Block Nested Loop), Using join buffer(Batched Key Access), Using join buffer(hash join)`
        - MySQL 옵티마이저는 조인되는 두 테이블에 있는 각 칼럼에서 인덱스를 조사하고 인덱스가 없는 테이블이 있으면 그 테이블을 먼저 읽어서 조인을 실행한다.
            - 드리븐 테이블의 조인 칼럼에 적절한 인덱스가 없다면 서버는 블록네스티드 루프 조인이나 해시조인을 사용한다.
    - `Using MRR`
        - MySQL 엔진은 여러 개의 키 값을 한 번에 스토리지 엔진으로 전달하고 스토리지 엔진은 넘겨받은 키 값들을 정렬해서 최소한의 페이지 접근만으로 필요한 레코드를 읽을 수 있게 최적화
    - `Using sort_union, Using union, Using intersect`
        - index_merge 접근 방법으로 실행되는 경우 두 개의 인덱스를 어떻게 병합했는지 표시
            - sort_union → 프라이머리 키만 먼저 읽어서 정렬하고 병합한다.
    - `Using temporary`
        - MySQL 서버에서 쿼리를 처리할 때 중간 결과를 담아 두기 위해 임시 테이블을 생성하는 경우 표시된다.
            - 메모리 or 디스크에 생성되는데 실행 계획만으로는 알 수 없다.
    - `Using where`
        - MySQL 스토리지 엔진에서 얻어온 레코드를 MySQL 엔진에서 별도로 가공하는 경우에만 Using where 코멘트가 표시된다.
    - `Zero Limit`
        - MySQL 서버에서 데이터 값이 아닌 쿼리 결괏값의 메타 데이터만 필요한 경우 쿼리 마지막에 LIMIT 0 를 사용하면 된다.
        - 옵티마이저도 이러한 사용자의 의도를 알아채고 레코드를 읽지 않고 메타정보만 반환한다.
        - 이 때 Zero limit 메시지가 출력된다.