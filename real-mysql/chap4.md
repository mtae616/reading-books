## Architecture

- MySQL 엔진
    - 사람의 머리 역할
- 스토리지 엔진
    - 손발 역할
    - 핸들러 API 를 만족하면 누구든 스토리지 엔진을 구현해서 MySQL 서버에 추가해서 사용 할 수 있다.
        - InnoDB 스토리지 엔진
        - MyISAM 스토리지 엔진

## MySQL 엔진 아키텍처

- 다른 DBMS 에 비해 구조가 독특
    - 장/단이 있음
- 대부분의 프로그래밍 언어로부터 접근 방법을 모두 지원
    - C
    - JDBC
    - ODBC…
- MySQL 엔진 + 스토리지 엔진 → MySQL 서버

### MySQL 엔진

- 주요 구성
    - 커넥션 핸들러
        - 클라이언트로부터의 접속 및 쿼리 요청을 처리
    - SQL 파서 및 전처리기
    - 옵티마이저
        - 쿼리의 최적화된 실행을 도움
- ANSI 표준

### 스토리지 엔진

- 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 역할
- 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.
- 아래와 같이 테이블이 사용할 스토리지 엔진을 지정하면 이후 해당 테이블의 모든 읽기/변경 작업은 정의된 스토리지 엔진이 처리한다.
    - `CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;`
    - InnoDB 스토리지 엔진을 사용하도록 정의
    - INSERT, UPDATE, DELETE  … 작업을 InnoDB 스토리지 엔진이 담당
- 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MySAM 스토리지 엔진) InnoDB 버퍼 풀(InnoDB 스토리지 엔진) 과 같은 기능을 내장하고 있다.

### 핸들러 API

- 핸들러 요청
    - 쿼리 실행기가 데이터를 쓰거나 읽어야 할 때 스토리지 엔진에 쓰기 또는 읽기를 요청하는 것
    - 여기에 사용하는 API 를 핸들러 API 라고 한다.
- InnoDB 스토리지 엔진 또한 이 핸들러 API 를 이용해 MySQL 엔진과 데이터를 주고 받는다.

## MySQL 스레딩 구조

- MySQL 서버는 스레드 기반으로 작동
    - Foreground Thread
        - MySQL 서버에 접속된 클라이언트이 수만큼 존재
        - 주로 각 클라이언트 사용자가 요청하는 쿼리 문장 처리
        - 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시 (Thread cache) 로 돌아감
            - 이때 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 한다.
            - 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 thread_cache_size 시스템 변수로 설정
        - 데이터를 MySQL 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업 처리
        - MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만
        - InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.
        - **참고**
            - Thread Cache
                - 클라이언트 연결을 처리하기 위한 새로운 스레드 생성을 최소화하기 위해 사용되는 메모리 캐시
                - 스레드를 재사용하여 생성/소멸 비용을 줄이기 위함
                - Thread pool 같은 거인듯
    - Background Thread
        - MyISAM 의 경우에는 별로 해당 사항이 없는 부분이지만 InnoDB 는 다음과 같이 여러가지 작업이 백그라운드로 처리된다.
            - Insert Buffer 를 병합하는 스레드
            - **`로그를 디스크로 기록하는 스레드`**
            - `InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드`
                - Write Thread
            - 데이터를 버퍼로 읽어 오는 스레드
                - Read Thread
            - 잠금이나 데드락을 모니터링 하는 스레드
        - Write Thread 와 Read Thread 는 2개 이상 지정할 수 있게 됐음
        - InnoDB 에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드는 많이 설정할 필요가 없지만
            - 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 일반적인 내장 디스크를 사용할 때는 2 ~ 4 정도, DAS 나 SAN 과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다
            - 데이터 쓰기 작업은 지연(버퍼링) 되어 한번에 일괄 처리할 수 있다.
                - InnoDB 또한 이러한 방식으로 처리한다.
            - 읽기 작업은 지연될 수 없다.
            - InnoDB 에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다.
        - MyISAM 은 사용자 스레드가 읽기/쓰기 모두 처리하도록 되어있다.
            - 쓰기 버퍼링 기능을 사용할 수 없다.
    - `SELECT thread_id, name, type, processlist_user, processlist_host FROM performance_schema.threads ORDER by type, thread_id;`
        - 실행 중인 스레드의 목록은 performance_schema 테이블의 threads 테이블을 통해 확인할 수 있다.
        - 책에서는 44개 중 41개 백그라운드 4개만 포그라운드라는데 나는 40 개 중에 3개만 포그라운드 였음
        - 동일한 이름의 스레드가 2개 이상씩 보이는 것은 MySQL 서버의 설정 내용에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우


## 메모리 할당 및 사용 구조

- 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당된다.
    - OS 에 따라 다르지만, 요청된 메모리 공간을 100% 할당해줄 수도 있고
    - 그 공간만큼 예약해두고 필요할 때 조금씩 할당해주는 경우도 있다.
    - 그냥 단순히 MySQL 시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리를 할당받는다고 생각
- 글로벌 메모리 영역과 로컬(세션) 메모리 영역은 MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.

### 글로벌 메모리 영역

- 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다.
    - 단 필요에 따라 2개 이상의 메모리 공간을 할당 받을 수도 있다. (여전히 클라이언트 스레드와 무관)
    - 생성된 글로벌 영역이 N 개라 하더라고 모든 스레드에 의해 공유된다.
- 대표적인 글로벌 메모리 영역
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼

### 로컬 메모리 영역

- 세션 메모리 영역
- 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
- 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하며 사용하는 영역
    - 클라이언트 메모리 영역, 로컬 메모리 영역, 세션 메모리 영역 등으로 부름
- 각 클라이언트 스레드별로 독립적으로 할당된다.
- 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 메모리 공간을 할당조차도 하지 않을 수도 있다.
    - sort buffer
    - join buffer
- 커넥션이 열려 있는 동안 계속 할당된 살태로 남아잇는 공간
    - 커넥션 버퍼
    - 결과 버퍼
- 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간
    - 소트 버퍼
    - 조인 버퍼
- 대표적인 로컬 메모리 영역
    - 정렬 버퍼 (sort buffer)
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼

## 플러그인 스토리지 엔진 모델

- 플러그인 형태로 제공하는 모델
    - 스토리지 엔진
    - 검색어 파서 (인덱싱할 키워드를 분리해내는 작업)
    - Native Authentication
    - Caching SHA-2 Authentication
- 기본 제공되는 스토리지 엔진 외에 직접 스토리지 엔진을 개발하여 사용 가능

- 사용자가 스토리지 엔진을 개발하여 사용하여도, 데이터 읽기/쓰기만 하는 일부분의 기능만 수행한다.
- 읽기/쓰기는 1건의 레코드 단위로 처리된다.
- 핸들러 : 어떤 기능을 호출하기 위해 사용하는 운전대와 같은 객체
    - MySQL 엔진이 스토리지 엔진을 조정하기 위해 핸들러 라는 것을 사용한다.
    - MySQL 엔진이 스토리지 엔진에게 데이터를 읽어오거 저장하도록 명령하려면 반드시 핸들러를 통해야 한다.
    - `Handler_` 로 시작하는 변수는 MySQL 엔진이 스토리지 엔진에게 보낸 명령의 횟수를 의미하는 변수
- GROUP BY 나 ORDER BY 등 복잡한 처리는 스토리지 엔진 영역이 아니라 MySQL 엔진의 처리 영역인 쿼리 실행기에서 처리된다.

### 컴포넌트

- 기존의 플러그인 아키텍처를 대체하기 위한 아키텍처
- 플러그인은 다음과 같은 단점이 존재한다.
    - 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리 통신 불가
    - MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
    - 플러그인 상호 의존 관계를 설정할 수 없어서 초기화 어려움

## 쿼리 실행 구조

### 쿼리 파서

- 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL 이 인식할 수 있는 최소 단위의 어휘나 기호) 로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미
- 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메세지를 전달하게 된다.

### 전처리기

- 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인
- 각 토큰을 테이블 이름이나 칼럼 이름 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정
- 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러진다.

### 옵티마이저

- 요청으로 들어온 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할 담당
- DBMS 의 두뇌
- 아주 중요

### 실행 엔진

- 실행 엔진과 핸들러는 손과 발에 비유할 수 있다.
- 옵티마이저가 group by 를 처리하기 위한 과정
    - 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
    - 다시 실행 엔진은 where 절에 일치하는 레코드를 읽어 오라고 핸들러에게 요청
    - 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
    - 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
    - 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

### 핸들러 (스토리지 엔진)

- 핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할
- 핸들러는 결국 스토리지 엔진을 의미

### 복제

- 16 장에서 알아봄..

### 쿼리 캐시

- 빠른 응답
- SQL 실행 결과를 메모리에 캐시
- 만약 테이블의 데이터가 변경되면 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 것들을 모두 삭제해야 한다.
    - 심각한 동시 처리 성능 저하
- 결국 쿼리 캐시는 8.0에 들어서 완전 제거 됨

### 스레드 풀

- 엔터프라이즈 에디션에서는 제공
- 아래에서 상술하는 스레드 풀은 Percona Server 에서 제공하는 스레드 풀
    - 플러그인 형태로 작동
- 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다하더라도 MySQL 서버의 CPU 가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적
    - 눈에 띄는 성능 향상은 드물다
    - 스레드들을 CPU 가 최대한 잘 처리해낼 수 있는 수준으로 빨리 처리하게 하는 기능
    - Context Switch 를 가장 적게하기 위함인들
- Percona Server 의 스레드 풀은 기본적으로 CPU 코어의 개수만큼 스레드 그룹을 생성
    - 일반적으로 CPU 코어의 개수와 맞추는 것이 CPU 프로세서 친화도를 높이는 데 좋다.
- 스레드 풀의 모든 스레드가 일하고 있다면 새로 생성할지 완료할 때까지 기다릴지 여부를 정해야함
    - 새로 생성할 때에는 thread_pool_max_threads 개수를 넘길 수 없음
    - 만약 기다릴 때에는 지금 처리 중인 작업을 끝내지 못하면 새로운 스레드를 생성한다.
        - thread_pool_stall_limit 시간 동안 기다려야만 새로 생성한다.

### 트랜잭션 지원 메타데이터

- 테이블 구조 정보, 스토어드 프로그램 등의 정보
- 5.7 까지는 테이블 구조를 FRM 파일에 저장하고 스토어드 프로그램 또한 파일로 관리함
    - 생성 및 변경 작업이 트랜잭션을 지원하지 않음
    - 테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남는 문제가 있음
- 8.0 부터는 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 InnoDB 의 테이블에 저장한다.
    - 시스템 테이블(MySQL 서버가 작동하는 데 기본적으로 필요한 테이블들) 또한 여기에 있다.
    - mysql.idb 라는 이름의 파일
    - 서버가 비정상적으로 종료되더라도 완전한 성공 또는 실패로 정리된다.
- MyISAM 이나 CSV 같은 스토리지 엔진은 SDI(Serialized Dictionary Information) 파일을 사용한다.

## InnoDB 스토리지 엔진 아키텍처

- InnoDB 는 MySQL 에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

### 프라이머리 키에 의한 클러스터링

- 모든 테이블은 프라이머리 키를 기준으로 클러스터링 되어 저장된다.
    - 프라이머리 키 값의 순서대로 디스크에 저장된다.
    - 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.
    - 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리도리 수 있다.
    - 결과적으로 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다 (쿼리의 실행 계획에서 다른 보조 인덱스보다 프라이머리 키가 선택될 확률이 높은)
- MyISAM 테이블의 프라이머리  키를 포함한 모든 인덱스는 물리적인 레코드의 주소 값(ROWID)를 가진다.

### 외래 키 지원

- 외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능, MyISAM 이나 MEMORY 테이블에서는 사용할 수 없다.
- InnoDB 에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의하는 것이 좋다.
- 만약 외래 키 체크를 하지 않을 경우에는 foreign_key_checks 를 OFF 로 하면 일시적으로 멈출 수 있다.

### MVCC (Multi Version Concurrency Control)

- 레코드 레벨의 트랜잭션을 지원하는 DBMS 가 제공하는 기능
- 잠금을 사용하지 않는 일관된 읽기를 제공한다.
- InnoDB 는 Undo log 를 이용해 이 기능을 구현한다.
- 멀티 버전이라고 하면 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 뜻이다.
    - 데이터를 update 하고 commit 하지 않았다면 파일에는 반영돼 있을 수도 있고, 아닐 수도 있다.
    - 격리 수준에 따라 다르다.
    - 만약 격리 수준이 READ_UNCOMMITTED 인 경우 InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다.
        - 즉 데이터가 커밋 됐든 아니든 변경된 상태의 데이터를 반환한다.
    - 그렇지 않고 READ_COMMITTED 나 그 이상의 격리 수준 (REPEATABLE_READ, SERIALIZABLE) 인 경우 아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 연영의 데이터를 반환한다.
    - → 이러한 과정을 DBMS 에는 MVCC 라고 표현한다.
    - 이 상태에서 COMMIT 하면 InnoDB 는 더이상 변경 작업 없이 지금의 상태를 영구 데이터로 만든다.
        - 언두 영역을 필요로 하는 transaction이 없으면 삭제된다.
    - ROLLBACK 하면 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 복구하고, 언두 영역의 내용을 삭제한다.
- 참고
    - `UNDO 영역`
        - 트랜잭션 처리, 데이터 일관성 유지, 롤백 기능, MVCC 같은 고급 기능 제공
        - UPDATE, DELETE, INSERT 와 같은 데이터 변경 작업 발생 이전의 데이터 버전을 저장

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- InnoDB 스토리지 엔진은 MVCC 를 통해 잠금 없는 읽기 작업을 수행
- 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 읽기 작업이 가능하다
- 격리 수준이 SERIALIZABLE 이 아닌 READ_UNCOMMITTED 나 READ_COMMITTED, REPEATABLE_READ 수준인 경우 INSERT 와 연결되지 않은 순수한 읽기 작업은 다른 트랜잭션의 변경 작업과 관계 없이 항상 잠금을 대기하지 않고 바로 실행된다.
- 특정 사용자가 레코드를 변경하고 아직 사용하지 않았다 하더라도 다른 사용자의 select 작업을 방해하지 않는다.