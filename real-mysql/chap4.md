## Architecture

- MySQL 엔진
    - 사람의 머리 역할
- 스토리지 엔진
    - 손발 역할
    - 핸들러 API 를 만족하면 누구든 스토리지 엔진을 구현해서 MySQL 서버에 추가해서 사용 할 수 있다.
        - InnoDB 스토리지 엔진
        - MyISAM 스토리지 엔진

## MySQL 엔진 아키텍처

- 다른 DBMS 에 비해 구조가 독특
    - 장/단이 있음
- 대부분의 프로그래밍 언어로부터 접근 방법을 모두 지원
    - C
    - JDBC
    - ODBC…
- MySQL 엔진 + 스토리지 엔진 → MySQL 서버

### MySQL 엔진

- 주요 구성
    - 커넥션 핸들러
        - 클라이언트로부터의 접속 및 쿼리 요청을 처리
    - SQL 파서 및 전처리기
    - 옵티마이저
        - 쿼리의 최적화된 실행을 도움
- ANSI 표준

### 스토리지 엔진

- 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 역할
- 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.
- 아래와 같이 테이블이 사용할 스토리지 엔진을 지정하면 이후 해당 테이블의 모든 읽기/변경 작업은 정의된 스토리지 엔진이 처리한다.
    - `CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;`
    - InnoDB 스토리지 엔진을 사용하도록 정의
    - INSERT, UPDATE, DELETE  … 작업을 InnoDB 스토리지 엔진이 담당
- 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MySAM 스토리지 엔진) InnoDB 버퍼 풀(InnoDB 스토리지 엔진) 과 같은 기능을 내장하고 있다.

### 핸들러 API

- 핸들러 요청
    - 쿼리 실행기가 데이터를 쓰거나 읽어야 할 때 스토리지 엔진에 쓰기 또는 읽기를 요청하는 것
    - 여기에 사용하는 API 를 핸들러 API 라고 한다.
- InnoDB 스토리지 엔진 또한 이 핸들러 API 를 이용해 MySQL 엔진과 데이터를 주고 받는다.

## MySQL 스레딩 구조

- MySQL 서버는 스레드 기반으로 작동
    - Foreground Thread
        - MySQL 서버에 접속된 클라이언트이 수만큼 존재
        - 주로 각 클라이언트 사용자가 요청하는 쿼리 문장 처리
        - 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시 (Thread cache) 로 돌아감
            - 이때 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 한다.
            - 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 thread_cache_size 시스템 변수로 설정
        - 데이터를 MySQL 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업 처리
        - MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만
        - InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.
        - **참고**
            - Thread Cache
                - 클라이언트 연결을 처리하기 위한 새로운 스레드 생성을 최소화하기 위해 사용되는 메모리 캐시
                - 스레드를 재사용하여 생성/소멸 비용을 줄이기 위함
                - Thread pool 같은 거인듯
            - Forground 에서 쓰면 Thread Cache
            - Background 에서 쓰면 Thread Pool
    - Background Thread
        - MyISAM 의 경우에는 별로 해당 사항이 없는 부분이지만 InnoDB 는 다음과 같이 여러가지 작업이 백그라운드로 처리된다.
            - Insert Buffer 를 병합하는 스레드
            - **`로그를 디스크로 기록하는 스레드`**
            - `InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드`
                - Write Thread
            - 데이터를 버퍼로 읽어 오는 스레드
                - Read Thread
            - 잠금이나 데드락을 모니터링 하는 스레드
        - Write Thread 와 Read Thread 는 2개 이상 지정할 수 있게 됐음
        - InnoDB 에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드는 많이 설정할 필요가 없지만
            - 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 일반적인 내장 디스크를 사용할 때는 2 ~ 4 정도, DAS 나 SAN 과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다
            - 데이터 쓰기 작업은 지연(버퍼링) 되어 한번에 일괄 처리할 수 있다.
                - InnoDB 또한 이러한 방식으로 처리한다.
            - 읽기 작업은 지연될 수 없다.
            - InnoDB 에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다.
        - MyISAM 은 사용자 스레드가 읽기/쓰기 모두 처리하도록 되어있다.
            - 쓰기 버퍼링 기능을 사용할 수 없다.
    - `SELECT thread_id, name, type, processlist_user, processlist_host FROM performance_schema.threads ORDER by type, thread_id;`
        - 실행 중인 스레드의 목록은 performance_schema 테이블의 threads 테이블을 통해 확인할 수 있다.
        - 책에서는 44개 중 41개 백그라운드 4개만 포그라운드라는데 나는 40 개 중에 3개만 포그라운드 였음
        - 동일한 이름의 스레드가 2개 이상씩 보이는 것은 MySQL 서버의 설정 내용에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우


## 메모리 할당 및 사용 구조

- 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당된다.
    - OS 에 따라 다르지만, 요청된 메모리 공간을 100% 할당해줄 수도 있고
    - 그 공간만큼 예약해두고 필요할 때 조금씩 할당해주는 경우도 있다.
    - 그냥 단순히 MySQL 시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리를 할당받는다고 생각
- 글로벌 메모리 영역과 로컬(세션) 메모리 영역은 MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.

### 글로벌 메모리 영역

- 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다.
    - 단 필요에 따라 2개 이상의 메모리 공간을 할당 받을 수도 있다. (여전히 클라이언트 스레드와 무관)
    - 생성된 글로벌 영역이 N 개라 하더라고 모든 스레드에 의해 공유된다.
- 대표적인 글로벌 메모리 영역
    - 테이블 캐시
    - InnoDB 버퍼 풀
        - db 캐시 메모리의 일종
        - 데이터 캐시
        - 인덱스 캐시
        - 쓰기 버퍼
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼

### 로컬 메모리 영역

- 세션 메모리 영역
- 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
- 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하며 사용하는 영역
    - 클라이언트 메모리 영역, 로컬 메모리 영역, 세션 메모리 영역 등으로 부름
- 각 클라이언트 스레드별로 독립적으로 할당된다.
- 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 메모리 공간을 할당조차도 하지 않을 수도 있다.
    - sort buffer
    - join buffer
- 커넥션이 열려 있는 동안 계속 할당된 상태로 남아잇는 공간
    - 커넥션 버퍼
    - 결과 버퍼
- 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간
    - 소트 버퍼
    - 조인 버퍼
- 대표적인 로컬 메모리 영역
    - 정렬 버퍼 (sort buffer)
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼

## 플러그인 스토리지 엔진 모델

- 플러그인 형태로 제공하는 모델
    - 스토리지 엔진
    - 검색어 파서 (인덱싱할 키워드를 분리해내는 작업)
    - Native Authentication
    - Caching SHA-2 Authentication
- 기본 제공되는 스토리지 엔진 외에 직접 스토리지 엔진을 개발하여 사용 가능

- 사용자가 스토리지 엔진을 개발하여 사용하여도, 데이터 읽기/쓰기만 하는 일부분의 기능만 수행한다.
    - 스토리지 엔진의 처리 영역만
- 읽기/쓰기는 1건의 레코드 단위로 처리된다.
- 핸들러 : 어떤 기능을 호출하기 위해 사용하는 운전대와 같은 객체
    - MySQL 엔진과 스토리지 엔진 사이에 위치한다.
    - MySQL 엔진이 스토리지 엔진을 조정하기 위해 핸들러 라는 것을 사용한다.
    - MySQL 엔진이 스토리지 엔진에게 데이터를 읽어오고 저장하도록 명령하려면 반드시 핸들러를 통해야 한다.
    - `Handler_` 로 시작하는 변수는 MySQL 엔진이 스토리지 엔진에게 보낸 명령의 횟수를 의미하는 변수
- GROUP BY 나 ORDER BY 등 복잡한 처리는 스토리지 엔진 영역이 아니라 MySQL 엔진의 처리 영역인 쿼리 실행기에서 처리된다.

### 컴포넌트

- 기존의 플러그인 아키텍처를 대체하기 위한 아키텍처
- 플러그인은 다음과 같은 단점이 존재한다.
    - 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리 통신 불가
    - MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
    - 플러그인 상호 의존 관계를 설정할 수 없어서 초기화 어려움

## 쿼리 실행 구조

### 쿼리 파서

- 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL 이 인식할 수 있는 최소 단위의 어휘나 기호) 로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미
- 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메세지를 전달하게 된다.

### 전처리기

- 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인
- 각 토큰을 테이블 이름이나 칼럼 이름 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정
- 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러진다.

### 옵티마이저

- 요청으로 들어온 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할 담당
- DBMS 의 두뇌
- 아주 중요

### 실행 엔진

- 실행 엔진과 핸들러는 손과 발에 비유할 수 있다.
- 옵티마이저가 group by 를 처리하기 위한 과정
    - 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
    - 다시 실행 엔진은 where 절에 일치하는 레코드를 읽어 오라고 핸들러에게 요청
    - 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
    - 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
    - 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

### 핸들러 (스토리지 엔진)

- 핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할
- 핸들러는 결국 스토리지 엔진을 의미

### 복제

- 16 장에서 알아봄..

### 쿼리 캐시

- 빠른 응답
- SQL 실행 결과를 메모리에 캐시
- 만약 테이블의 데이터가 변경되면 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 것들을 모두 삭제해야 한다.
    - 심각한 동시 처리 성능 저하
- 결국 쿼리 캐시는 8.0에 들어서 완전 제거 됨

### 스레드 풀

- 엔터프라이즈 에디션에서는 제공
- 아래에서 상술하는 스레드 풀은 Percona Server 에서 제공하는 스레드 풀
    - 플러그인 형태로 작동
- 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다하더라도 MySQL 서버의 CPU 가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적
    - 눈에 띄는 성능 향상은 드물다
    - 스레드들을 CPU 가 최대한 잘 처리해낼 수 있는 수준으로 빨리 처리하게 하는 기능
    - Context Switch 를 가장 적게하기 위함인듯
- Percona Server 의 스레드 풀은 기본적으로 CPU 코어의 개수만큼 스레드 그룹을 생성
    - 일반적으로 CPU 코어의 개수와 맞추는 것이 CPU 프로세서 친화도를 높이는 데 좋다.
- 스레드 풀의 모든 스레드가 일하고 있다면 새로 생성할지 완료할 때까지 기다릴지 여부를 정해야함
    - 새로 생성할 때에는 thread_pool_max_threads 개수를 넘길 수 없음
    - 만약 기다릴 때에는 지금 처리 중인 작업을 끝내지 못하면 새로운 스레드를 생성한다.
        - thread_pool_stall_limit 시간 동안 기다려야만 새로 생성한다.

### 트랜잭션 지원 메타데이터

- 테이블 구조 정보, 스토어드 프로그램 등의 정보
- 5.7 까지는 테이블 구조를 FRM 파일에 저장하고 스토어드 프로그램 또한 파일로 관리함
    - 생성 및 변경 작업이 트랜잭션을 지원하지 않음
    - 테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남는 문제가 있음
- 8.0 부터는 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 InnoDB 의 테이블에 저장한다.
    - 시스템 테이블(MySQL 서버가 작동하는 데 기본적으로 필요한 테이블들) 또한 여기에 있다.
    - mysql.idb 라는 이름의 파일
    - 서버가 비정상적으로 종료되더라도 완전한 성공 또는 실패로 정리된다.
- MyISAM 이나 CSV 같은 스토리지 엔진은 SDI(Serialized Dictionary Information) 파일을 사용한다.

## InnoDB 스토리지 엔진 아키텍처

- InnoDB 는 MySQL 에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

### 프라이머리 키에 의한 클러스터링

- 모든 테이블은 프라이머리 키를 기준으로 클러스터링 되어 저장된다.
    - 프라이머리 키 값의 순서대로 디스크에 저장된다.
    - 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.
    - 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리도리 수 있다.
    - 결과적으로 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다 (쿼리의 실행 계획에서 다른 보조 인덱스보다 프라이머리 키가 선택될 확률이 높은)
- MyISAM 테이블의 프라이머리  키를 포함한 모든 인덱스는 물리적인 레코드의 주소 값(ROWID)를 가진다.
- **참고**
    - MySQL 에서 사용하는 paging 이라는 기법을 사용
    - os 의 paging 과는 다르고, 오히려 MMU 에 가까움
    - 논리적인 데이터를 일정한 크기로 나눠서 저장하고 메모리 주소 맵핑

### 외래 키 지원

- 외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능, MyISAM 이나 MEMORY 테이블에서는 사용할 수 없다.
- InnoDB 에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의하는 것이 좋다.
- 만약 외래 키 체크를 하지 않을 경우에는 foreign_key_checks 를 OFF 로 하면 일시적으로 멈출 수 있다.

### MVCC (Multi Version Concurrency Control)

- 레코드 레벨의 트랜잭션을 지원하는 DBMS 가 제공하는 기능
- 잠금을 사용하지 않는 일관된 읽기를 제공한다.
- InnoDB 는 Undo log 를 이용해 이 기능을 구현한다.
- 멀티 버전이라고 하면 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 뜻이다.
    - 데이터를 update 하고 commit 하지 않았다면 파일에는 반영돼 있을 수도 있고, 아닐 수도 있다.
    - 격리 수준에 따라 다르다.
    - 만약 격리 수준이 READ_UNCOMMITTED 인 경우 InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다.
        - 즉 데이터가 커밋 됐든 아니든 변경된 상태의 데이터를 반환한다.
    - 그렇지 않고 READ_COMMITTED 나 그 이상의 격리 수준 (REPEATABLE_READ, SERIALIZABLE) 인 경우 아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 연영의 데이터를 반환한다.
    - → 이러한 과정을 DBMS 에는 MVCC 라고 표현한다.
    - 이 상태에서 COMMIT 하면 InnoDB 는 더이상 변경 작업 없이 지금의 상태를 영구 데이터로 만든다.
        - 언두 영역을 필요로 하는 transaction이 없으면 삭제된다.
    - ROLLBACK 하면 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 복구하고, 언두 영역의 내용을 삭제한다.
- 참고
    - `UNDO 영역`
        - 트랜잭션 처리, 데이터 일관성 유지, 롤백 기능, MVCC 같은 고급 기능 제공
        - UPDATE, DELETE, INSERT 와 같은 데이터 변경 작업 발생 이전의 데이터 버전을 저장

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- InnoDB 스토리지 엔진은 MVCC 를 통해 잠금 없는 읽기 작업을 수행
- 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 읽기 작업이 가능하다
- 격리 수준이 SERIALIZABLE 이 아닌 READ_UNCOMMITTED 나 READ_COMMITTED, REPEATABLE_READ 수준인 경우 INSERT 와 연결되지 않은 순수한 읽기 작업은 다른 트랜잭션의 변경 작업과 관계 없이 항상 잠금을 대기하지 않고 바로 실행된다.
- 특정 사용자가 레코드를 변경하고 아직 사용하지 않았다 하더라도 다른 사용자의 select 작업을 방해하지 않는다.

### 자동 데드락 감지

- InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리한다.
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 강제 종료한다.
- 어느 트랜잭션을 먼저 강제 종료할 것인지 판단 기준
    - 트랜잭션의 언두 로그 양 → 더 적게 가진 트랜잭션
    - 언두 로그 양이 적은 것은 롤백할 양도 적은 것이므로 서버 부하가 적음
- MySQL 엔진에서 관리되는 테이블 잠금은 볼 수 없어서 데드락 감지가 불확실 할 수도 있는데
    - innodb_table_locks 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금 감지할 수 있게 된다.
    - 위 시스템 변수를 활성화하는 것이 좋다.
- 동시 처리 스레드가 많거나, 각 트랜잭션이 가진 lock 개수가 많아지면 데드락 감지 스레드가 느려진다.
    - 데드락 감지 스레드는 잠금 목록을 lock 걸어 관리
    - 따라서 데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 미침
    - 이런 악영향을 위해 innodb_deadlock_detect 를 false 로 둬서 데드락 감지 스레드를 끌 수 있음(…?)
        - 당연히 데드락 무한정 발생…
    - innodb_lock_wait_timeout 을 설정하면 일정 시간이 지나면 자동으로 요청 실패함
        - 초단위 설정
        - lock 을 설정한 시간 동안 획득하지 못하면 쿼리는 실패하고 에러 반환
        - innodb_dealock_detect 보다 이 값을 낮게 설정하는 게 나음

### 자동화된 장애 복구

- InnoDB 스토리지 엔진은 매우 견고해서 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않는다.
    - 하드웨어 이슈는 못 피함 → 복구가 쉽지 않음…
    - InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 자동 복구 수행
    - 만약 자동복구 할 수 없다면 MySQL 서버 종료됨
- 위의 경우라면 innodb_force_recovery 설정해서 MySQL 시작해야 함
    - InnoDB 의 로그 파일이 손상됐다면 6으로 설정하고 MySQL 기동
    - InnoDB 테이블의 데이터 파일이 손상됐다면 1
    - 어떤 부분인지 모르면 1 ~ 6 전부 설정
    - 만약 MySQL 서버가 기동 된다면 dump 떠서 백업 후 테이블 다시 생성

## InnoDB 버퍼 풀

- InnoDB 스토리지 엔진에서 가장 핵심
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐싱해 두는 공간
- 쓰기 작업을 지연시켜 일괄 작업 처리
- 쿼리가 INSER, UPDATE, DELETE 같은 랜덤한 디스크 작업 발생 시 한 번에 모아서 처리하게하여 디스크 작업의 횟수를 줄여줌

### 버퍼 풀의 크기 설정

- 운영체제와 각 클라이언트 스레드가 사용할 메모리를 충분히 고려해야 한다.
- 레코드 버퍼가 상당한 메모리를 사용하기도 한다.
    - 레코드 버퍼
        - 각 클라이언트 세션에서 테이블의 레코드를 읽고 슬 때 버퍼로 사용하는 공간
    - 커넥션이 많고 사용하는 테이블도 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 꽤 많아짐
    - 별도로 설정할 수 없고 전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블 개수에 따라 결정됨
    - 동적으로 해제되기도 함
- 5.7 이후부터는 버퍼 풀의 크기를 동적으로 조절할 수 있게 개선
    - 적절히 작은 값으로 설정해서 조금씩 상황을 봐 가면서 증가
    - 운영체제의 전체 메모리가 8GB 미만이라면
        - 50% 정도만 InnoDB 버퍼 풀로 설정
        - 나머지는 MySQL 서버, 운영체제, 다른 프로그램이 사용
    - 그 이상이라면
        - InnoDB 버퍼 풀의 크기를 전체 메모리의 50% 에서 시작해서 조금씩 올려가며 최적점을 찾음
        - 전체가 50GB 이상이라면 약 15 ~ 30GB 를 운영체제와 다른 응용 프로그램을 위해 남겨두고 나머지를 InnoDB 버퍼 풀로 할당
- innodb_buffer_pool_size 시스템 변수로 크기 설정
    - 동적으로 버퍼 풀 크기 확장
    - 버퍼 풀 크기는 크리티컬한 변경이므로 한가한 시점에 해야함
    - 버퍼 풀을 줄이는 것은 하면 안됨…
- 버퍼 풀은 128MB 청크 단위로 관리
    - 버퍼 풀의 크기를 줄이거나 늘릴 때는 128MB 단위 처리
- InnoDB 버퍼 풀은 원래는 버퍼 풀 전체를 관리하는 잠금(세마포어)로 관리하여 내부 잠금 경합을 많이 유발했는데
    - 현재는 버퍼 풀을 여러 개로 쪼개어 관리
    - 개별 버퍼 풀 전체를 관리하는 lock(semaphore) 도 lock striping 됨
    - 1GB 미만이면 버퍼 풀 1개, 40GB 이하 수준이라면 기본값이 8개

### 버퍼 풀의 구조

- InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 각 조각에 저장
    - 페이지 크기 → innodb_page_size 시스템 변수에 설정됨
- 버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB 스토리지 엔진은 아래의 자료구조를 관리함
    - LRU (Least Recentrly Used)
        - 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 버퍼 풀의 메모리에 유지
        - LRU 와 MRU(Most Recently Used) 가 결합된 형태
        - Old Sublist 는 LRU
        - New Sublist 는 MRU
        - InnoDB 스토리지 엔진에서 데이터를 찾는 과정
            1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
                1. InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
                2. 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지를 검색
                3. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
            2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
            3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더로 이동
            4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 Age 가 부여되며 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고 결국 해당 페이지는 버퍼 풀에서 제거 됨
                1. 버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화 되어 다시 젊어지고 MRU 헤더 부분으로 옮겨진다.
            5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가
    - List, Flush List
        - 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록 관리
        - 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록해야함
        - 데이터가 변경되면 InnoDB 는 변경 내용을 리두 로그에 기록, 버퍼 풀의 데이터 페이지에도 변경
    - Free List
        - 비워있는 페이지들의 목록
        - 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용

### 버퍼 풀과 리두 로그

- 버퍼 풀과 리두 로그는 매우 밀접한 관계를 맺고 있다.
- 디스크의 데이터가 버퍼 풀 메모리로 적재되면 성능이 좋아진다.
- 서버 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 두가지 용도가 있다.
    - 버퍼 풀의 메모리 공간만 단순히 늘리는 것은 캐시 기능만 향상 시키는 것이다.
    - 버퍼 풀의 쓰기 버퍼링 기능까지 향상시키려면 InnoDB 버퍼 풀과 리두 로그와의 관계를 먼저 이해해야 한다.
- 클린 페이지
    - 디스크에서 읽은 상태로 전혀 변경되지 않은 데이터
- 더티 페이지
    - insert, update, delete 명령으로 변경된 데이터
    - 무한정 버퍼 풀에 머무를 수는 없다.
    - 디스크와 메모리(버퍼 풀) 의 데이터 상태가 다르기 때문에 디스크로 기록돼야 한다.
- 리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용한다.
    - 데이터 변경이 계속 발생하면 리두 로그 파일에 기록됐던 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰인다.
    - 따라서 InnoDB 스토리지 엔진은 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리해야 한다.
        - 재사용 불가능한 공간 → 활성 리두 로그(Active Redo Log)
- 리두 로그 파일의 공간은 계속 순환되어 재사용되지만 매번 기록될 때마다 로그 포지션은 계속 증가된 값을 갖는다.
    - 이를 LSN(Log Sequence Number) 라고 한다.
    - InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화한다.
    - 체크포인트 중 가장 최근 체크포인트 지점의 LSN 이 활성 리두 로그 공간의 시작점이 된다.
    - 가장 최근 체크포인트의 LSN 과 마지막 리두 로그 엔트리의 LSN 차이를 체크포인트 에이지 라고 한다.
    - 즉 체크포인트 에이지는 활성 리두 로그 공간의 크기를 일컫는다.
- InnoDB 버퍼 풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지고 체크포인트가 발생하면 체크포인트 LSN 보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화돼야 한다.
    - 물론 체크포인트 LSN 보다 작은 LSN 값을 가진 리두 로그 엔트리도 디스크로 동기화 돼야 한다.


### 버퍼 풀 플러시

- MySQL 5.6 버전까진 InnoDB 스토리지 더티 페이지 플러시 기능이 그다지 부드럽게 처리되지 않음
    - 디스크 기록이 폭증할 때 사용자 쿼리 처리 성능에 영향을 받는 경우가 많았음
- 5.7 을 거쳐 8.0 에서는 더티 페이지를 디스크에 동기화하는 부분에서 예전과 같은 디스크 쓰기 폭증 현상은 발생하지 않는다.
- InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 다음과 같이 2개의 플러시 기능을 백그라운드로 실행
    - Flush_list flush
        - 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워야 함
        - 이때 오래된 리두 로그 공간이 지워지려면 반드지 InnoDB 버퍼 풀의 더티 페이지가 먼저 디스크로 동기화돼야 한다.
        - 이를 위해 InnoDB 스토리지 엔진은 주기적으로 Flush_list 플러시 함수를 호출해서 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행함
        - 이때 언제부터 얼마나 많은 더티 페이지를 한 번에 디스크로 기록하느냐에 따라 사용자의 쿼리 처리가 악영향을 받지 않으면서 부드럽게 처리됨
        - 이를 위해 제공하는 시스템 변수들
            - innodb_page_cleaners
                - 더티 페이지를 디스크로 동기화하는 스레드(클리너 스레드) 개수를 조정
                - 하나의 클리너 스레드가 하나의 버퍼 풀 인스턴스를 처리하도록 자동으로 맞춰줌
                - innodb_page_cleaners 시스템 변수의 설정값이 버퍼 풀 인스턴스보다 작은 경우 하나의 클리너 스레드가 여러 버퍼 풀 인스턴스를 처리한다.
            - innodb_max_dirty_pages_pct_lwm
                - 이 값을 기준으로 조금씩 더티 페이지를 디스크로 기록
            - innodb_max_dirty_pages_pct
                - 기본적으로 InnoDB 스토리지 엔진은 전체 버퍼 풀이 가진 페이지의 90%까지 더티 페이지를 가질 수 있는데, 이를 조정하는 시스템 변수
                - 가능하면 기본값 유지가 좋음
            - innodb_io_capacity
                - 데이터베이스 서버에서 어느 정도의 디스크 읽고 쓰기가 가능한지 설정하는 값
                - 일반적인 상황에서 디스크가 처리할 수 있는 수준의 값
            - innodb_io_capacity_max
                - 데이터베이스 서버에서 어느 정도의 디스크 읽고 쓰기가 가능한지 설정하는 값
                - 최대 서능 발휘할 때 어느 정도의 디스크 읽기 쓰기
            - innodb_flush_neighbors
                - 디스크에 근접한 페이지 중에서 더티 페이지가 있다면 InnoDB 스토리지 엔진이 함꼐 묶어서 디스크로 기록하게 해주는 기능 활성 여부
                - 비활성이 좋음
            - innodb_adaptive_flushing
                - 리두 로그가 어느 정도 속도로 증가하는지 분석해서 플러싱
            - innodb_daptive_flushing_lwm
                - 리두 로그가 어느 정도 속도로 증가하는지 분석해서 플러싱
                - 기본값 10% 로 활성 리두 로그 공간이 10% 넘어서면 어댑티브 플러시 알고리즘 작동
    - LRU_list flush
        - 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만듬
        - 시스템 변수
            - innodb_lru_sca_depth
                - Lru 끝부분부터 시작해서 위 변수 값에 설정된 개수만큼의 페이지 스캔
                - 이때 스캔하면서 더티 페이지는 디스크에 동기화
                - 클린 페이지는 즉시 free list 로 옮김