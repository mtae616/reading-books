# 인덱스

- 쿼리 성능에 중요한 요인

## 디스크 읽기 방식

- Random I/O
    - SDD (NAND Flash)
- Sequential I/O
    - HDD

### HDD, SDD

- SDD 는 arm 없이 메모리로 I/O
- DRAM 보단 느리지만 HDD 보단 빠름
    - CPU > DRAM > SSD
- Random I/O 에서 SDD가 훨신 빠른 속도를 보임
    - sequential 에서는 비슷하거나 SDD 가 빠름

### 랜덤 I/O, 순차 I/O

- HDD
    - 3개의 페이지를 기록하기 위해 1번의 시스템 콜 요청
- SDD
    - 3개의 페이지를 기록하기 위해 3번 시스템 콜 호출
    - 디스크 원판을 가지지 않지만 랜덤I/O 와 순차 I/O 에서 차이가 있다
        - 순차 I/O 가 처리량이 더 높음
- 디스크를 쓰고 읽는 데 걸리는 시간은 디스크 헤더를 움직이는 데 결정됨
    - 즉 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐
- 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적
    - 랜덤 I/O 를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리 개선하는 것

## 인덱스?

- 책의 찾아보기 → 인덱스
- 책의 내용 → 데이터 파일
- 책의 찾아보기를 통한 페이지 번호 → 데이터 파일에 저장된 레코드 주소
- 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 걸려 칼럼의 값과 해당 레코드가 저장된 주소를 키 밸류 쌍으로 인덱스를 만들어 둔다.
- 또한 인덱스는 정렬되어 있다.
- SortedList
    - 인덱스와 같은 자료 구조
    - 값을 정렬해야 해서 느리지만, 찾을 때는 빠름
- ArrayList
    - 데이터 파일과 같은 자료 구조
- 인덱스는 저장 성능을 희생하고 읽기 속도를 높임
- 인덱스의 역할별 분류
    - PK
        - 레코드를 대표하는 컬럼의 값
        - 레코드를 구분하는 기준값, 식별자
        - NULL, 중복을 허용하지 않음
    - Secondary Index
        - PK 제외 나머지
        - 유니크 인덱스는 PK 와 성격이 비슷해서 대체 키라고도 부름
- 인덱스의 저장 방식별 구분
    - B-Tree
        - 일반적으로 사용하는 알고리즘
        - 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱
        - R-Tree 인덱스도 B-Tree 의 응용
    - Hash
        - 컬럼의 값으로 해시값을 계산해서 인덱싱
        - 매우 빠른 검색
        - 값을 변형해서 인덱싱하므로 전방 일치와 같이 값의 일부만 검색하거나 범위 검색에서는 사용할 수 없다.
        - 주로 메모리 기반의 데이터베이스에서 많이 쓰인다.
    - Unique, Non-Unique 는 옵티마이저에게 굉장히 중요한 문제

## B-Tree 인덱스

- 가장 범용
- B 는 Balanced
- 원래 값을 변형시키지 않고 정렬된 상태로 유지

### 구조 및 특성

- 루트 노드
- 브랜치 노드
- 리프 노드
    - 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
- 데이터 파일은 순서대로 레코드가 적혀있지 않다.
    - 빈 공간이 생기면 단편화를 막아야 하니까 거기에 저장함
- 인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 레코드를 찾아야 한다.

- InnoDB 는 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한번 더 검색한 후
    - 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
    - 즉 InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree 를 다시 한 번 검색해야 한다.
    - **참고**
        - 다시 말한다면 PK 를 통해서는 바로 B-Tree 를 탄다.
        - 데이터 파일 자체가 PK 를 갖고 있는 B-Tree 이기 때문에

### B-Tree 인덱스 키 추가 및 삭제

- **인덱스 키 추가**
    - 새로운 키 값이 B-Tree 에 저장될 때 스토리지 엔진에 따라 바로 저장될 수도, 아닐 수도 있음
    - B-Tree 의 적절한 위치를 검색해야 함
    - 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree 리프 노드에 저장
    - 리프노드가 꽉 차서 저장할 수 없을 때는 리프 노드를 분리해야 한다.
        - 상위 브랜치 노드가지 처이의 범위가 넓어 진다.
        - 상대적으로 쓰기 작업 비용이 많이 든다.
    - INSERT, UPDATE 작업은 컬럼 수, 크기, 인덱스 칼럼의 특성 등을 확인해야 cost 산정 가능
        - Insert 비용이 1 이면 키 추가는 1.5로 예측
        - e.g. 테이블에 3개의 인덱스가 있었다면
            - 5.5 (1.5 * 3 + 1) 정도로 예측
            - 메모리와 CPU 에서 처리하는 시간이 아니라 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 해서 걸리는 시간
- **인덱스 키 삭제**
    - 상당히 간단
    - 리프 노드 찾아서 삭제 마크만
        - 키 공간은 그대로 방치하거나 재활용
        - 마킹 작업 또한 I/O 작업이 필요하므로 버퍼링되어 지연처리 될 수 있음
- **인덱스 키 변경**
    - 인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로
        - B-Tree 의 키 값이 변경되는 경우 단순히 인덱스상의 키 값만 변경하는 것은 불가능
        - 키 값 변경 작업은 먼저 키 값을 삭제한 후 다시 새로운 키 값을 추가하는 형태로 처리
- **인덱스 키 검색**
    - INSERT, UPDATE, DELETE 관리 비용을 감당하는 것은 빠른 검색을 위해서
        - 루트 → 브랜치 → 리프 : 트리 탐색
        - UPDATE 나 DELETE 를 처리하기 위해 레코드를 먼저 검색해야 하는 경우에도 트리 탐색
        - 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.
            - 키 값의 앞부분(Left-most part) 는 가능
        - 인덱스의 값에 변형이 가해진 경우에도 빠른 검색은 기대할 수 없다.
    - InnoDB 에서는 넥스트 키 락(갭락) 이 검색을 수해항 인덱스를 잠근 후 레코드를 잠그는 방식으로 구현돼 있다.
        - 따라서 UPDATE 나 DELETE 문장이 실행될 때 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.

### B-Tree 인덱스 사용에 영향을 미치는 요소

- 영향을 미치는 요소
    - 칼럼의 크기
    - 레코드의 건수
    - 유니크한 인덱스 키 값의 개수
- **인덱스 키 값의 크기**
    - 디스크 읽기/쓰기 최소 단위 → 페이지(≒ 블록)
    - 버퍼 풀에서 데이터를 버퍼링하는 기본 단위
    - 인덱스도 결국 페이지 단위로 관리
        - 루트와 브랜치 리프를 구분한 기준이 바로 페이지 단위
    - B-Tree 가 이진 트리라면 상당히 비효율적
        - 자식 노드의 개수가 가변적인 구조
        - 인덱스의 페이지 크기와 키 값의 크기에 따라 자식 개수가 달라짐
        - 만약 페이지 크기가 16KB 이고
            - 인덱스의 키가 16Byte, 자식 노드 주소가 12Byte 라면
            - 16 * 1024(16KB) / (16 + 12) = 585, 자식 노드의 개수도 585개다
            - 만약 인덱스 키가 32 Byte 로 커지면
            - 16 * 1024(16KB) / (32 + 12) = 372 개로 작아진다.
            - 16Byte 인덱스 키로 500 개 레코드를 읽어야 한다면 한 번으로 해결되지만
            - 32Byte 로는 2번에 걸쳐 읽어야 하므로 효율이 떨어진다.
- **B-Tree 깊이**
    - 깊이는 중요하지만 직접 제어할 방법은 없다.
    - 깊이가 3인 경우 키 값이 16 바이트라면
        - 최대 2억 (585 * 585 * 585) 개의 키 값을 가질 수 있다.
    - 깊이가 3인 경우 키 값이 32바이트 라면
        - 최대 5천만 (372 * 372 * 372) 개로 줄어든다.
- **선택도(기수성)**
    - 선택도(Selectivity) 또는 기수성(Cardinality) 는 거의 같은 의미
        - 모든 인덱스 키 값 가운데 유니크한 값의 수
    - 전체 인덱스 키 값은 100인데 그중에서 유니크한 값의 수는 10개라면 기수성은 10
    - 중복되는 값이 많은 인덱스는 비효율적이다.
    - 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다.
- **읽어야 하는 레코드의 건수**
    - 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업
        - 만약 100만건 중 50만건을 읽는다면,
        - 전체를 읽어서 50만건을 버리는 것이 효율적일지, 인덱스를 통해 필요한 50만 건만 읽어 오는 것이 효율적일지 판단해야 함
    - 일반적인 DBMS 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4 ~ 5 배 비용이 더 많이 드는 작업인 것으로 예측
        - 즉 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20 ~ 25% 를 넘어서면
        - 인덱스를 사용하지 않고 모두 읽어서 필터링으로 수행

### B-Tree 인덱스를 통한 데이터 읽기

- **인덱스 레인지 스캔**
    - 대표적이며 가장 빠른 방식
    - 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
    - 루트 노드부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야만 비로소 필요한 레코드의 시작 지점을 찾을 수 있다.
    - 시작 지점을 찾으면 그때부터 리프 노드의 레코드만 순서대로 읽으면 된다.
    - 페이지를 끝까지 읽으면 리프 노드 간의 링크를 통해서 다음 리프 노드를 찾아 다시 스캔

- **인덱스 레인지 스캔**
    - 실제로 레코드를 읽어와야 하는 경우는
        - 레인지 스캔 후 역순 혹은 정순으로 찾아온다.
        - 또한 중요한 것은 레코드를 읽어오는 과정이 필요하다는 것이다.
        - 레코드 한 건 한 건 단위로 랜덤 I/O 가 한 번씩 일어난다.
    - 인덱스 레인지 스캔은 다음과 같이 크게 3단계를 거친다.
        1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. 이 과정을 인덱스 탐색 이라고 한다.
        2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. 이 과정을 인덱스 스캔 이라고 한다.
            1. 1, 2 번을 합쳐 인덱스 스캔으로 통칭하기도 한다.
        3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어 온다.

- **인덱스 풀 스캔**
    - 인덱스의 처음부터 끝까지 다 읽는 방식
    - 인덱스는 (A, B, C) 칼럼의 순서로 만들어 졌는데 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우
        - 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수  있는 경우 주로 이 방식이 사용된다.
        - 테이블을 전부 읽는 것 보다 인덱스를 읽는 것이 빠르기 때문에
        - 인덱스뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 이 방식으로 처리되지 않는다.

- **루스 인덱스 스캔**
    - Oracle 에서는 인덱스 스킴 스캔이라고 한다.
    - 느슨하게 또는 듬성듬성 인덱스를 읽는다.
    - 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어간다.
    - GROUP BY, MAX, MIN 함수에 대한 최적화에 사용된다.

    ```sql
    SELECT dept_no, MIN(emp_no)
    FROM dept_emp
    WHERE dept_no BETWEEN 'd002' AND 'd004'
    GROUP BY dept_no;
    ```

    - 위 그림을 예제로
        - dept_emp 는 dept_no 와 emp_no 라는 두개 칼럼으로 인덱스가 생성되어 있다.
        - 이미 dept_no, emp_no 조합으로 정렬되어 있어서
        - dept_no 그룹별로 첫 번째 레코드의 emp_no 만 읽으면 된다.
    - 루스 인덱스 스캔을 사용하려면 여러 조건을 만족해야 한다.

- **인덱스 스킵 스캔**
    - 인덱스의 핵심은 값이 정렬돼 있다는 것
    - 인덱스를 구성하는 칼럼의 순서가 매우 중요

    ```sql
    -- 이런 인덱스가 있다는 가정
    ALTER TABLE employees ADD INDEX ix_gender_birthdate(gender, birth_date);
    
    -- 인덱스를 사용하지 못하는 쿼리
    select * from employees where birth_date >= '1965-02-01';
    
    -- 인덱스를 사용할 수 있는 쿼리
    select * from employees where gender = 'M' AND birth_date >= '1965-02-01';
    ```

    - MySQL 8.0 부터는 옵티마이저가 gender 칼럼을 건너뛰어서 birth_date 칼럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 도입

    - gender 칼럼에서 유니크한 값만 가지고 와서, birth_date 를 조건에 추가해서 다시 검색 수행
    - 위 그림에서 보이는 2개의 쿼리를 실행해서 최적화한다.
    - 단점
        - where 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
            - 값이 매우 많다면 시작 지점을 검색하는 작업이 많이 필요해짐
        - 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)

- **다중 칼럽(Multi-column) 인덱스**
    - 2개 이상의 칼럼을 포함하는 인덱스
    - 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬
    - 두 번째 컬럼의 정렬은 첫 번째 컬럼이 똑같은 레코드에서만 의미가 있다는 것


### B-Tree 인덱스의 정렬 및 스캔 방향

- 설정한 정렬 규칙에 따라 항상 오름차순/내림차순
    - 오름차순으로 생성했다고 해서 항상 오름차순으로 읽을 수 있다는 것은 아니다.
    - 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정된다.
- **인덱스의 정렬**
    - MySQL 8.0 에서는 정렬 순서를 혼합한 인덱스도 생성할 수 있게 됐다.
    - `CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);`

- **인덱스 스캔 방향**
    - 역순, 정순 모두 가능한 것을 옵티마이저는 알고 있다.
    - `SELECT * FROM employees ORDER BY first_name DESC LIMIT 5;`
        - 역순으로 읽으면서 처음 다섯 개 레코드만 가져오면 된다.
- **내림차순 인덱스**

    ```sql
    CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
    ```

    - 복합 인덱스에서 각각의 컬럼이 내림차순과 오름차순이 혼합된 경우 내림차순 인덱스로만 해결될 수 있다.

    ```sql
    CREATE INDEX ix_firstname_asc ON employees (first_name ASC);
    CREATE INDEX ix_firstname_desc ON employees (first_name DESC);
    ```

    - 위의 상황에서 first_name 컬럼을 역순으로 정렬하는 요건만 있다면 다음 2개의 인덱스 중에서 어떤 것을 선택하는 것이 좋을까?

    - 오름차순 인덱스(Ascending index)
        - 작은 값의 인덱스 키가 B-Tree 의 왼쪽으로 정렬된 인덱스
    - 내림차순 인덱스 (Descending index)
        - 큰 값의 인덱스 키가 B-Tree 왼쪽으로 정렬된 인덱스
    - 인덱스 정순 스캔 (Forward index scan)
        - 인덱스 키의 크고 작음에 관계 없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
    - 인덱스 역순 스캔 (Backward index scan)
        - 인덱스 키의 크고 작음에 관계 없이 인덱스 리프 노드의 오른쪽 페이지 부터 왼쪽으로 스캔
    - 1200만 건을 스캔하는데 정순 스캔이 역순 스캔보다 1.2초 정도 빠르다
        - 역순 정렬 쿼리가 정순 정렬 쿼리보다 28.9% 느리다.

    - 느릴 수 밖에 없는 이유
        - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
        - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조
    - **따라서 내림차순으로 정렬하고자 하면 인덱스를 내림차순으로 만들고 ascending 으로 스캔하는 것이 바람직하다**


### B-Tree 인덱스의 가용성과 효율성

- Where 조건이나 group by, order by 에서 인덱스를 사용/식별할 수 있는지
- **비교 조건의 종류와 효율성**

- “=”, “<”, “>”

```sql
SELECT * FROM dept_emp where dept_no='d002' and emp_no >= 10114;

-- case a : index(dept_no, emp_no)
-- case b : index(emp_no, dept_no)
```

- case A는 “dept_no='d002' and emp_no >= 10114” 인 레코드를 찾고
    - dept_no 가 ‘d002’ 가 아닐 때까지 인덱스를 그냥 쭉 읽기만 하면 된다.
    - 만약 조건을 만족하는 레코드가 5건이면 5건의 비교 작업만 하므로 효율적이다.
- case b 는 “emp_no >= 10114 and dept_no='d002' ” 인 레코드를 찾고
    - 모든 레코드에 대해 dept_no 가 d002 인지 확인해야 한다.
    - 만약 emp_no >= 10114 에 해당하는 레코드가 7건이면 7건 모두 확인해야 하니 비효율 적이다.
- **인덱스의 가용성**
    - 왼쪽 값에 기준해서(Left-most) 오른쪽 값이 정렬돼 있다.
    - `select * from employees where fist_name like ‘%mer’;`
        - first_name 에 인덱스가 걸려 있어도 이 쿼리는 인덱스를 사용하지 못한다.
        - 만약 ‘mer%’ 라면 가능하다.
    - select * from dept_emp where emp_no ≥ 10144;
        - 인덱스가 (dept_no, emp_no) 순서대로 생성돼 있다면 인덱스의 선행 칼럼인 dept_no 조건 없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용할 수 없다.
        - dept_no 칼럼에 대해 먼저 정렬한 후 다시 emp_no 컬럼값으로 정렬돼 잇기 때문이다.
- **가용성과 효율성 판단**
    - B-Tree 인덱스의 특성상 다음 조건에서는 작업 범위 결정 조건으로 사용할 수 없다.
    - NOT-EQUAL 로 비교된 경우
        - <>
        - NOT IN
        - IS NOT NULL
    - LIKE 앞 부분이 아닌 뒷부분 일치
        - LIKE ‘%taesu’
        - LIKE ‘_taesu’
        - LIKST ‘%태%’
    - 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우
        - substring(clumn,1,1) = ‘X’
    - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
        - deterministic_function()
    - 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우)
    - 문자열 데이터 타입의 콜레이션이 다른 경우
    - INDEX ix_test (column_1, column_2, column_3, …, column_n)
        - 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
            - column_1 컬럼에 대한 조건이 없는 경우
            - column_1 컬럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
        - 작업 범위 결정 조건으로 인덱스를 사용하는 경우
            - column_1 ~ column_(i - 1) 컬럼까지 동등 비교 형태 (’=’ 또는 ‘in’)로 비교
            - column_i 컬럼에 대해 다음 연산자 중 하나로 비교
                - 동등 비교
                - > <
                - 좌측 LIKE

## R-Tree 인덱스

- 2차원 데이터를 인덱싱하고 검색하는 목적
- R-Tree 인덱스는 2차원의 공간 개념 값
- 공간 확장
    - 공간 데이터를 저장할 수 있는 데이터 타입
    - 공간 데이터의 검색을 위한 공간 인덱스
    - 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)

### 구조 및 특성

- GEOMETRY
    - POINT
    - LINE
    - POLYGON
- MBR, Minimum Bounding Rectangle
    - 도형을 감싸는 최소 크기의 사각형
    - 이 사각형의 포함 형태를 B-Tree 로 구현한 인덱스가 R-Tree

- 최상위 레벨
    - R1, R2
    - R-Tree 의 루트 노드에 저장
- 차상위 레벨
    - R3, R4, R5, R6
    - 브랜치 노드에 저장
- 최하위 레벨
    - R7 ~ R14
    - 각 도형 데이터의 MBR

### R-Tree 인덱스의 용도

- 공간 인덱스
- WGS84 기준의 위도, 경도 좌표에 주로 사용
    - CAD/CAM 또는 회로 디자인 등과 같이 좌표 시스템에 기반을 둔 정보에 모두 사용
- R-Tree 는 각 도형의 포함 관계를 이용해 만들어진 인덱스

## 전문 검색 인덱스

- 특정 키워드가 포함된 문서를 검색하는 전문(Full Text) 검색에는 InnoDB 나 MyISAM에서 제공하는 일반적인 B-Tree를 사용할 수 없다.

### 인덱스 알고리즘

- 전문 검색에서는 빠른 검색용으로 키워드를 인덱스로 구축한다.
- n-gram
- **어근 분석 알고리즘**
    - 색인 작업은 아래의 두가지 작업을 거친다.
        - 불용어 처리
            - 가치 없는 단어 필터링
        - 어근 분석
            - MeCab 사용 → 완성도를 갖추기 어렵다.
- **n-gram 알고리즘**
    - MeCab 을 보완
    - 키워드를 검색해내기 위한 인덱싱 알고리즘
    - 본문을 몇글자씩 잘라서 인덱싱
    - n 은 인덱싱할 최소 글자 수
        - 일반적으로 2글자인 Bi-gram 이 잘 쓰인다.

    - `To be or not to be. That is the question`
        - 각 단어 10개
        - 2글자씩 중첩해서 토큰으로 분리
        - 여기에서 불용어 걸러서 삭제한다.
        - 불용어는 MySQL 에 기본 내장
- **불용어 변경 및 삭제**
    - MySQL 내장 불용어 대신 사용자가 직접 등록하는 것을 권장

## 함수 기반 인덱스

- 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축할 때 사용
    - 가상 칼럼을 이용한 인덱스
    - 함수를 이용한 인덱스
- 함수 기반 인덱스는 값을 계산하는 과정의 차이만 있을 뿐 B-Tree 인덱스와 동일하다.

```sql
alter table user
	add full_name varchar(30) as (concat(first_name, ' ', last_name)) virtual,
	add index ix_fullname(full_name);
```

- 위의 경우가 가상으로 인덱스를 설정하는 경우

```sql
create table user(
	user_id bigint,
	fist_name varchar(10),
	last_name varchar(10),
	INDEX ix_fullname ((concat(first_name, ' ',las_name)))
);
```

- 위의 경우가 함수를 이용
    - 제대로 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 한다.

## 멀티 밸류 인덱스

- 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태
    - JSON
        - 일반적인 RDBMS 에서는 정규화 위배
        - JSON 을 지원하면서 도입

```sql
create table user(
	credit_info JSON,
	INDEX mx_creditscores ( (CAST(CREDIT_INFO -> '$.credit_scores' AS UNSIGNED ARRAY)) )

)

INSERT INTO user values ('{"credit_scores" : [360, 353, 351]}')
```

- 멀티 밸류 인덱스를 활용하기 위해서는 일반적인 조건 방식을 사용하면 안 되고 다음과 같은 함수들을 반드시 사용해야 옵티마이저가 인덱스를 활용한다..
    - MEMBER OF()
    - JSON_CONTAINS()
    - JSON_OVERLAPS()

## 클러스터링 인덱스

- 여러개를 하나로 묶는다.
- 레코드를 비슷한 것(프라이머리 키를 기준으로)들끼리 묶어서 저장

### 클러스터링 인덱스

- 프라이머리 키에 대해서만 적용되는 내용
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다
    - 또한 프라이머리 키 값이 변경된다면 레코드의 물리적인 저장 위치가 바뀐다.
    - 프라이머리 키 값에 대한 의존도가 상당히 크기 때문에 신중히 프라이머리 키를 결정해야 한다.
- 테이블 레코드의 저장 방식이라고 볼 수 있다.
    - 클러스터링 인덱스와 클러스터링 테이블은 동의어로 쓰여지기도 한다.
    - 프라이머리 키는 클러스터링 키라고도 표현한다.
- 일반적으로 InnoDB 와 같이 항상 클러스터링 인덱스로 저장하는 테이블은 프라이머리 키 기반의 검색이 매우 빠르다
    - 대신 레코드의 저장이나 프라이머리 키 변경이 상대적으로 느리다.

- B-Tree 와 비슷하다
    - 하지만 세컨더리 인덱스를 위한 B-Tree 의 리프 노드와는 달리 클러스터링 인덱스의 리프노드에는 레코드의 모든 칼럼이 저장돼 있다.
- 만약 이 상황에서 2번이 추가된다면 1번 다음 2번이 추가될 것이다.
- 만약 PK 가 없다면 InnoDB 스토리지 엔진이 다음의 순서로 PK 를 대체할 컬럼을 선택한다.
    1. 프라이머리 키가 있으면 기본적으로 PK 선택
    2. NOT NULL 옵션의 UNIQUE INDEX 중에서 첫 번째 인덱스 선택
    3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가 후 선택

### 세컨더리 인덱스에 미치는 영향

- PK 가 세컨더리 인덱스에 미치는 영향
- ROWID
    - MyISAM, MEMORY 테이블은 정렬되지 않고 무작위로 저장되며 ROWID 로 각 레코드를 구분
    - 따라서 PK 와 secondary index 가 구조적으로 다르지 않음
    - index 가 레코드의 주소를 갖고 있으므로 index 를 통해서 바로 레코드를 가져온다.
- 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면
    - 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고
    - 모든 인덱스에 저장된 주소값을 바꿔줘야 한다.
    - 따라서 InnoDB 는 secondary index 는 PK 주소 값을 저장한다.
    - secondary index 가 PK 의 주소값을 가지고 있으므로 pk 를 확인한 후 pk를 검색하여 레코드를 가져온다.

### 클러스터링 인덱스의 장점과 단점

- 장점
    - PK 로 검색할 때 빠름
    - secondary index 가 PK 를 가지고 있으므로 인덱스만으로 처리할 수 있는 경우가 많음
- 단점
    - secondary index 가 clustering key(pk) 를 가지므로 pk 가 클 경우 인덱스 크기가 커짐
    - secondary index 가 pk 를 거쳐 검색하므로 성능이 느림
    - insert 할 때 pk 에 의해 레코드의 저장 위치가 결정되기 때문에 성능이 느림
    - pk 변경할 때 레코드를 delete 하고 insert 하므로 처리 성능이 느림

### 클러스터링 테이블 사용 시 주의사항

- **클러스터링 인덱스 키의 크기**
    - pk 가 커지면 자동으로 secondary index 의 크기도 커진다.
    - secondary index 가 5개라면 아래와 같다.

| 프라이머리 키 크기 | 레코드당 증가하는 인덱스 크기 | 100 만건 레코드 저장 시 증가하는 인덱스 크기 |
| --- | --- | --- |
| 10byte | 10 byte * 5 = 50 byte | 50byte * 1000000 = 47MB |
| 50byte | 50byte * 5 = 250 byte | 250byte * 1000000 = 238MB |

- **프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 컬럼으로 생성(가능하면)**
    - PK 가 클러스터링 키이므로 레코드의 위치가 결정된다.
    - PK 로 검색하는 경우 매우 빠르게 처리된다.
    - 키의 크기가 크더라도 레코드를 대표할 수 있다면 PK 로 설정
- **프라이머리 키는 반드시 명시할 것**
    - AUTO_INCREMENT 를 사용해서라도 써라
    - 내부적인 일련번호는 사용자가 전혀 접근할 수 없다.
- **AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우**
    - 여러 복함으로 PK 가 만들어져 PK 가 큰 경우 secondary index 가 필요치 않다면 그대로 PK 를 사용하는 것이 좋다.
    - 만약 pk 도 길고 secondary index 필요하다면 AUTO-INCREMENT 를 pk 로 잡도록

## 유니크 인덱스

- 유니크는 인덱스보다 제약조건

### 유니크 인덱스와 일반 세컨더리 인덱스의 비교

- 구조적으로는 차이는 없다.
- **인덱스 읽기**
    - 유니크 인덱스는 세컨더리 인덱스에 비해 빠르지 않다.
    - 유니크 하지 않은 세컨더리 인덱스에서 레코드를 한 건 더 읽는 게 아니라 cpu 에서 컬럼을 비교하는 작업이기 때문에 이는 성능상 영향이 거의 없다.
        - 유니크 하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이지 인덱스 자체의 특성 때문에 느린 것이 아니라는 뜻
        - 즉 레코드 1건을 읽는 데 0.1 초 걸렸고, 2건을 읽을 때 0.2초가 걸렸다고 후자를 느리게 처리됐다고 할 수 없는 것과 같은 이치
- **인덱스 쓰기**
    - INSERT, UPDATE, DELETE 에 쓰기 작업
    - unique 인덱스는 중복 값을 체크해야하므로 한 단계 더 필요
        - 쓰기, 읽기 시 lock 걸면서 데드락이 빈번…
        - 또한 유니크 한지 체크하면서 change buffer 못 씀
    - 따라서 세컨더리 인덱스보다 쓰기가 느리다.

### 유니크 인덱스 사용 시 주의 사항

- 꼭 필요하면 사용하지만, 성능이 더 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하지 않는 게 좋다.

## 외래 키

- MySQL 에서 fk 는 InnoDB 에서만 생성할 수 있다
- fk 되면 연관되는 테이블의 컬럼에 인덱스까지 생성된다.
- 특징
    - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합이 발생한다.
    - fk 와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)를 발생시키지 않는다.

### 자식 테이블의 변경이 대기하는 경우

- 1번 커넥션 트랜잭션 시작
    - 부모 테이블에서 update
    - 이 과정에서 1번 커넥션 id 2인 레코드에 대해 쓰기 잠금 획득
    - 이 상황에서 자식 테이블에 변경 작업 수행
    - 이때 1번 커넥션이 완료 돼야 2번 커넥션이 완료 된다.
    - 즉 부모 테이블의 확인이 필요한데 lock 걸려있다면 해제될 때까지 대기해야 함

### 부모 테이블의 변경 작업이 대기하는 경우

- 자식 테이블 레코드 변경 중
    - 자식 테이블의 레코드에 대한 write lock 획득
    - 2번 커넥션에서 부모 레코드를 삭제하려고 하면 자식 테이블의 lock 해제될 때까지 대기
    - ON DELETE CASCADE 로 자식 레코드까지 삭제되어야 하기 때문에