# 프로그래밍 패러다임
- 고대 그리스어 파라데이그마
  - model || pattern || example
  - 하나의 예를 복사하도록 허용한다 -> 어떤 동사에 대한 활용 (사랑하다 -> amo, amas, amat)
- 현대 : 패러다임의 전환(paradigm shift) -> 천동설에서 지동설로 변화
  - 어떤 한 시대 사람들의 견해나 사고를 지배하고 있는 이론적 틀이나 개념의 집합체
- 프로그래밍 패러다임
  - 성숙한 개발자 공동체에 의해 수용된 프로그래밍 방법과 문제 해결 방법, 프로그래밍 스타일
  - 프로그래밍 패러다임은 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 함

## 객체, 설계
- 로버트 L. 글래스 : 이론보다 실무가 먼저다
  - 관찰한 결과를 토대로 이론을 정립하는 것이 최선
- 티켓 판매 애플리케이션
  - step1
    - 수동적인 존재가 된다
    - 외부 객체가 객체 내부의 상태를 고침
    - 결합도가 높다
  - step2
    - theater 에서 ticketseller 에만 접근(ticketseller 내부의 ticketoffice 에는 접근하지 않음, 결합도 낮춤)
      - TicketSeller 의 interface(sellTo) 에만 의존, ticketseller 가 내부에서 ticketoffice 로 구현하고 있음
      - audience - bag 도 비슷하게 변경
    - Audience 와 ticketSeller 가 내부 구현을 외부에 노출하지 않고 자신의 문제를 스스로 책임지고 해결
    - 결합도를 낮추고 응집도를 높임
    - 책임의 이동
      - step 1 과의 근본적인 차이
      - 책임 : 기능
      - step 1 에서는 theater 에 책임이 집중되어 있었음 -> 절차 지향적 방식
      - 그에 반해 step 2 에서는 책임이 여러 객체에 걸쳐 분산 돼 있었음 -> OOP
        - 책임의 이동
        - 책임이 적절하게 분배된다
        - 자신을 스스로 책임진다
  - step3
    - audience - bag 도 위와 마찬가지로 변경
    - ticketSeller 에서 TicketOffice 의 자율성을 위해 audience 를 넘겼으나, 오히려 ticketoffice 의 결합도를 높힘(ticketoffice - audience)
      - 위와 같은 상황은 tradeoff 고려, 결합도를 낮추거나 자율성을 낮추거나...
    - theater, bag, ticketoffice 는 실세계에서 자율적인 존재가 아님
      - 비록 현실에선 수동적인 존재라도 객체지향에서는 능동적이고 자율적인 존재
      - 의인화
- 설계
  - 좋은 설계
    - 2가지 요구 사항
      - 기능 구현
      - 유지 보수
  - 객체지향 설계
    - 변경에 유연하게 대응할 수 있는 코드
    - 이해하기 쉬운 코드
    - 