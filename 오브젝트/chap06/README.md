# 메시지와 인터페이스
- 클래스는 구현 도구다
- 클래스가 아니라 객체를 지향해야 한다, 객체가 수행하는 책임에 초점을 맞춰야 한다.
  - 책임이 객체가 수신할 수 있는 메시지의 기반이 된다.
- 객체지향 app 의 가장 중요한 재료는 클래스가 아니라 객체들이 주고받는 메시지다
- 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다.
- 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다.

## 협력과 메시지
- 클라이언트-서버 모델
  - 클라이언트가 메시지를 전송하면 수신한 객체는 요청을 적절히 처리한 후 응답 
  - 클라이언트 : 메시지를 전송하는 객체
  - 서버 : 메시지를 수신하는 객체
- 메시지와 메시지 전송
  - 객체들이 협력하기 위해 사용하는 의사소통 수단
  - 메시지 전송, 메시지 패싱 : 도움을 요청하는 것
    - 메시지 전송자, 클라이언트 : 전송 객체
    - 메시지 수신자, 서버 : 수신 객체
  - 메시지 전송 == (메시지 수신자, 오퍼레이션 명, 인자)
- 메시지와 메서드
  - 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.
  - 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다. (구현체가 다를 수 있음)
- 퍼블릭 인터페이스와 오퍼레이션
  - 퍼블릭 인터페이스 : 외부에 공개하는 메시지의 집합
  - 오퍼레이션 : 퍼블릭 인터페이스에 포함된 메시지
    - 수행 가능한 어떤 행동에 대한 추상화
    - 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처
  - 메서드 : 메시지를 수신했을 때 실제로 실행되는 코드
- 시그니처
  - 오퍼레이션(메서드)의 이름과 파라미터 목록을 합친 것
- 정리
  - 메시지
    - 다른 객체와 협력하기 위한 의사소통 메커니즘
    - 객체의 오퍼레이션이 실행되도록 요청하는 것을 메시지 전송이라고 한다
  - 오퍼레이션
    - 객체가 다른 객체에 제공하는 추상적인 서비스
    - 메시지를 수신하는 객체의 인터페이스만을 강조한다.
  - 메서드
    - 실제 실행되는 코드 구현
  - 퍼블릭 인터페이스
    - 외부에서 수신할 수 있는 메시지의 묶음
    - 클래스의 퍼블릭 메서드들의 집합, 메시지의 집합
  - 시그니처
    - 오퍼레이션이나 메서드의 명세
    - 이름과 인자의 목록을 포함

## 인터페이스와 설계 품질
- 인터페이스
  - 만족해야 하는 조건 
    - 최소한의 인터페이스 : 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다.
    - 추상적인 인터페이스 : 어떻게가 아니라 무엇을 하는지 표현
  - 위를 만족하기 위한 가장 좋은 방법은 책임 주도 설계를 따르는 것
- 디미터 법칙
  - 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한한다.
  - use only one dot
  - 아래 조건을 만족하는 인스턴스에만 메시지를 전송해야 한다.
    - this
    - 메서드의 매개변수
    - this 의 속성
    - this 의 속성인 컬렉션의 요소
    - 메서드 내에서 생성된 지역 객체
- 묻지말고 시켜라
  - 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다.
  - 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안된다.
  - 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.
  - 객체의 정보를 이용하는 행동을 객체 내부에 위치시킨다.
- 의도를 드러내는 인터페이스
  - 무엇을 하느냐에 따라 메서드의 이름을 짓는 것

## 원칙의 함정
- 디미터 법칙은 하나의 도트를 강제하는 규칙이 아니다
  - Stream 은 예외임
    - 객체의 내부 구조가 외부로 노출되는 것이 아닌 method chaning 이니까
- 결합도와 응집도의 충돌
  - 위임 메서드를 통해 객체의 내부 구조를 감추는 것은 협력에 참여하는 객체들의 결합도를 낮출 수 있는 동시에 객체의 응집도를 높일 수 있는 가장 효과적인 방법
  - 하지만 맹목적으로 위임 메서드를 추가하면 객체는 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 결과적으로 응집도가 낮아진다.
    - 객체는 자신의 책임만 수행해야 한다.
    - e.g. discountCondition 에서 조회하는 screening 의 필드를 조회한다고 해서 screening 에서 할인 조건을 conditioning 하면 screening 이 본질적으로 질 책임이 아닌 책임을 지게 됨

## 명령-쿼리 분리 원칙, Command-Query Separation
- 질문이 답변을 수정해서는 안 된다.
- 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈을 루틴이라고 한다
  - 루틴은 다시 프로시저, 함수로 구분한다.
  - 프로시저 : 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류
    - 프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
  - 함수 : 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류
    - 함수는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.
  - 명령 : 객체의 상태를 수정하는 오퍼레이션, == 프로시저
    - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
  - 쿼리 : 객체와 관련된 정보를 반환하는 오퍼레이션, == 함수
    - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
- 명령-쿼리 분리와 참조 투명성
  - 어떤 표현식 e 가 있을 때 e  의 값으로 e 가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성
- 책임에 초점을 맞춰라
  - 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하면 디미너, 묻지 말고 시켜라 법칙을 따르기 쉽게 됨
