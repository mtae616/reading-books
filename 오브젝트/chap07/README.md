# 객체 분해
- 너무 많은 정보의 양이 들어오면 인지 과부하에 걸리기 떄문에 이를 방지하기 위해 필요한 핵심 정보만 남긴다.
  - 이를 **추상화** 라고 한다.
- 가장 일반적인 추상화 방법은 문제의 크기를 줄이는 것이다.
  - 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 **분해**라고 부른다

## 프로시저 추상화와 데이터 추상화
- 프로시저 추상화
  - 소프트웨어가 무엇을 해야 하는지 추상화
  - 기능 분해 == 알고리즘 분해
- 데이터 추상화
  - 소프트웨어가 무엇을 알아야 하는지 추상화
  - 데이터 중심으로 타입을 추상화
    - 추상 데이터 타입
  - 데이터를 중심으로 프로시저를 추상화
    - 객체 지향

## 프로시저 추상화와 기능 분해
- 메인 함수로서의 시스템
  - 기능은 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용됐다
    - 알고리즘 분해 == 기능 분해
    - top down approach
    - 문제점
      - 시스템은 하나의 메인 함수로 구성돼 있지 않다
      - 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.
      - 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
      - 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.
      - 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.
    - 비즈니스 로직과 사용자 인터페이스의 결합
      - 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합된다.
      - 비즈니스 로직보다 사용자 인터페이스가 훨씬 많이 변경된다.
      - top down 은 사용자 인터페이스 로직과 비즈니스 로직을 한 데 섞기 때문에 사용자 인터페이스를 변경하는 경우에도 비즈니스 로직이 영향을 받아 불안정한 아키텍처를 낳는다.
    - 성급하게 결정된 실행 순서
      - 절차지향적 방식
      - what 이 아니라 how 다
      - 기능 분해 방식은 중앙집중 제어 스타일로 함수의 제어 구조가 빈번한 변경 대상이다.
      - 결합도가 높다
    - 데이터 변경으로 인한 파급효과
      - 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어려워 side effect 가 빈번
    - 유리한 경우
      - 작은 프로그램
      - 개별 알고리즘
      - 프로그래밍 과정에서 이미 해결된 알고리즘을 문서화하고 서술하는 데

## 모듈
- 정보 은닉과 모듈
  - 정보 은닉
    - 시스템이 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다.
    - 복잡성 : 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다.
    - 변경 가능성 : 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.
- 모듈의 장점과 한계
  - 장점
    - 모듈 내부의 변경되더라도 모듈 내부에만 영향을 미친다.
    - 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
    - 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.
  - 하지만 추상화 관점에서의 한계점이 명확하다
    - 인스턴스 개념을 제공하지 않는다는 점

## 데이터 추상화와 추상 데이터 타입
- 추상 데이터 타입
  - 추상 데이터 타입 구현을 위한 프로그래밍 언어의 지원
    - 타입 정의
    - 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의
    - 제공된 오페이션을 통해서만 조작
    - 타입에 대해 여러 개의 인스턴스 생성 가능

## 클래스
- 클래스는 추상 데이터 타입인가?
  - 클래스는 상속과 다형성을 지원하는데 추상 데이터 타입은 지원하지 못한다
  - 상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍 패러다임을 객체기반 프로그래밍이라고 한다.
  - 객체지향은 절차 추상화
    - 다형성을 통해 어떤 인터페이스를 상속받은 두 클래스는 외부에서 보기엔 같다
    - 내부에서 수행되는 절차는 다르지만 클래스를 이용한 다형성은 절차에 대한 차이점을 감춘다
      - 메소드 명은 같지만 내부 구현은 다름
- 변경을 기준으로 선택해라
  - 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다.
    - 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반한 것
    - employee - (salariedempoyee, hourlycomployee)
      - 상속 계층에 추가하고 필요한 메서드를 오버라이딩
      - 새로 추가된 클래스의 메서드를 실행하기 위한 어떤 코드도 추가할 필요가 없다.
    - OCP
      - 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가
      - 변경/확장하기 쉬운 구조
- 협력이 중요하다
  - 책임 주도 설계가 중요
  - 객체가 참여할 협력을 결정, 협력에 필요한 책임을 수행하기 위해 어떤 객체가 필요한지에 관해 고민해라
  - 그 책임을 다양한 방식으로 수행해야 할 때만 타입 계층 안에 각 절차를 추상화하라
  - 타입 계층과 다형성은 협력이라는 문맥 안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 한다
