# 서브클래싱과 서브타이핑
- 상속
  - 상속의 용도
    - 타입 계층 구현
      - 부모 클래스는 자식 클래스의 일반화 이고
      - 자식 클래스는 부모 클래스의 특수화 이다.
    - 코드 재사용 
  - 상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이어야 한다.
  - 상속은 부모 클래스와 자식 클래스를 강하게 결합시켜 설계의 변경과 진화를 방해한다.

## 타입
- 개념 관점의 타입
  - 우리가 인지하는 세상의 사물의 종류
  - 객체들에 적용하는 개념이나 아이디어
  - 공통의 특징을 공유하는 대상들의 분류
  - 타입의 3가지 요소
    - 심볼 : 타입에 이름을 붙인 것 (프로그래밍 언어)
    - 내연 : 공통적인 속성이나 행동 (컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합)
    - 외연 : 타입에 속하는 객체들의 집합 (자바, 루비, 자바스크립트, C...)
- 프로그래밍 언어 관점의 타입
  - 연속적인 비트에 의미와 제약을 부여하기 위해 사용
  - 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합
  - 두가지 목적
    - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.
    - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.
- 객체지향 패러다임 관점의 타입
  - 객체가 수신할 수 있는 메시지의 종류를 정의하는 것
  - 퍼블릭 인터페이스를 정의하는 것
  - 동일한 퍼블릭 인터페이스를 가지는 객체들은 동일한 타입으로 분류할 수 있다.
  - 동일한 상태를 갖더라도 퍼블릭 인터페이스가 다르다면 서로 다른 타입으로 분류된다.
  - 반대로 상태는 다르더라도 퍼블릭 인터페이스를 공유한다면 이들은 동일한 타입으로 분류된다.

## 타입 계층
- 타입 사이의 포함 관계
  - 자바 : 클래스 기반 < 객체지향 < 프로그래밍 언어
  - 포함하는 타입은 외연 관점에서는 더 크고 내연 관점에서는 더 일반적이다.
  - 포함되는 타입은 외연 관점에서는 더 작고 내연 관점에서는 더 특수하다
    - 프로그래밍 언어 타입은 객체지향 언어 타입보다 더 일반적이고
    - 객체지향 언어 타입은 클래스 기반 언어 타입보다 더 일반적이다
  - 더 일반적인 타입을 슈퍼타입이라고 부르고 더 특수한 타입을 서브타입이라고 부른다.
  - 내연 관점에서 일반화란 어떤 타입의 정의를 좀 더 보편ㅂ적이고 추상적으로 만드는 과정을 의미한다.
    - 반대로 특수화란 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정을 의미한다.
  - 집합을 의미하는 외연의 관점에서 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포함하는 슈퍼셋이다.
    - 반대로 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 서브셋이다.
- 객체지향 프로그래밍과 타입 계층
  - 객체의 타입을 결정하는 것은 퍼블릭 인터페이스다.
    - 일반적인 타입이란 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.
  - 슈퍼타입이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것이다.
  - 서브타입이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것이다.
- 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.

## 서브클래싱과 서브타이핑
- 언제 상속을 사용해야 하는가
  - 상속 관계가 is-a 관계를 모델링할 때
    - "자식 클래스는 부모 클래스다" 라고 말해도 이상하지 않을 때
  - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방할 때
    - 행동 호환성 : 상속 계층을 사용하는 클라이언트 입장에서 부모 클래스와 자식 클래스의 차이점을 모르는 것
- is-a 관계
  - 어떤 타입 S 가 다른 타입 T 의 일종이라면 타입 S 는 타입 T 다 라고 말할 수 있어야 한다.
    - 객체지향 언어는 프로그래밍 언어다
    - 클래스 기반 언어는 객체지향 언어다
  - 새의 정의가 날 수 있다는 것이라면, 펭귄은 새지만 펭귄은 날 수 없으므로 새의 서브타입이 될 수 없다.
    - 어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다.
    - 행동호환성
- 행동호환성
  - 이름 사이에 개념적으로 어떤 연관성이 있다고 하더라도 행동에 연관성이 없다면 is-a 관계를 사용하지 말아야 한다.
  - 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점이다.
  - 만약 펭귄이 그래도 새고, fly() 메서드를 써야 한다면
    - fly() 를 override 하고 내부 구현을 비워 둔다.
    - fly() 를 오버라디이 한 후 exception throw 한다
    - fly() 를 호출하는 부분에 penguin 이 아니면 fly() 를 호출하게 분기한다
- 클라이언트의 기대에 따라 계층 분리하기
  - 펭귄은 fly 를 호출하는 곳에 전달돼서는 안된다
  - 차라리 따로 fly 를 호출할 수 있는 FlyingBird class 를 새로 만들고 거기에 fly 를 포함시킨다
  - penguin 은 내부에 fly 오퍼레이션이 없음
  - 근데 차라리 인터페이스를 만들고 각각에 필요한 퍼블릭 인터페이스를 정의하고
  - 나중에 bird 에서 penguin 이 필요하면 합성하는 방식이 더 나음
  - ISP : 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙
- 서브클래싱과 서브 타이핑
  - 서브 클래싱
    - 코드를 재사용할 목적으로 상속을 사용하는 경우
    - 구현 상속, 클래스 상속이라고 부르기도 한다.
    - 내부 구현 자체를 상속받는 것에 초점을 맞추기 때문에 구현 상속 또는 클래스 상속이라고 부른다.
  - 서브 타이핑
    - 타입 계층을 구성하기 위해 상속을 사용하는 경우
    - 인터페이스 상속 이라고 부르기도 한다.
    - 서브타입의 퍼블릭 인터페이스가 슈퍼타입에서 정의한 퍼블릭 인터페이스와 동일하거나 더 많은 오퍼레이션을 포함해야 한다.
    - 개념적으로 서브 타입이 슈퍼타입의 퍼블릭 인터페이스를 상속받는 것처럼 보이게 된다. -> 인터페이스 상속이라고 부르는 이유
    - 행동호환성을 만족시켜야 하고 대체 가능성을 포함한다.
- 리스코프 치환 원칙
  - 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다.
  - 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용해야 한다.
- 클라이언트와 대체 가능성
  - 리스코프 치환 원칙은 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가는하다 는 결론을 이끈다
  - 상속 관계는 클라이언트 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을 때만 올바르다
    - Rectangle > square 의 관계라면
    - 필연적으로 서브클래싱이 될 수 밖에 없음
    - 생성자에 x, y, width, height 놓았을 때 square 는 생성자 내부에서 width height 가 같게 조정할 필요가 있음
    - 이 때 클라이언트가 만약 대체 가능성을 보고(rectangle 과 같다고 보고) width, heigth를 다르게 조정하는 순간 생성자 내부에서 같게 조정됨
    - 따라서 행동이 호환되지 않는 문제점 발생
  - 대체 가능성을 결정하는 것은 클라이언트다
- is-a 관계 다시 보기
  - 객체지향에서 중요한 것은 객체의 속성이 아니라 객체의 행동이다
  - 객체의 속성 측면에서 상속 관계를 정할 경우 리스코프 치환 원칙을 위반하는 서브클래싱에 이르게 될 확률이 높다.
  - 상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계다
- 리스코프 치환 원칙은 유연한 설계의 기반이다.
  - 새로운 자식 클래스를 추가하더라도 클라이언트의 입장에서 동일하게 행동하기만 한다면 클라이언트를 수정하지 않고도 상속 계층을 확장할 수 있다.
  - 클라이언트의 입장에서 퍼블릭 인터페이스의 행동 방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게 된다.

## 계약에 의한 설계와 서브타이핑
- 계약에 의한 설계 : 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현
  - 사전 조건 : 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 것
  - 사후 조건 : 메서드 실행 후 서버가 클라이언트에 보장해야 하는 것
  - 클래스 불변식 : 메서드 실행 전/후 인스턴스가 만족시켜야 하는 것
  - 서브 타입에 더 강력한 사전조건을 정의할 수 없다.
  - 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
  - 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
  - 서브타입에 더 약한 사후조건을 정의할 수 없다.
