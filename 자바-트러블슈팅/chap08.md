# 스레드

## 스레드 때문에 (스레드에서) 발생하는 문제들
- 하나의 CPU 성능을 향상시키는 것은 거의 한계에 다다랐기 때문에 코어 개수를 증가시키는 추세
- 스레드가 정상적으로 작동하지 않아서 발생하는 문제에 대해 서술

<br />

### WAS의 적절한 스레드 개수는 몇 개일까?
- 스레드 풀 설정에 관해 물어본다면 1000 ~ 2000 개 추천
- 절대값은 없지만 계산할 수 있다
  - 어떤 서비스에 대해서 부하 테스트 수행할 때
  - 가장 많이 사용하는 상위 80% 에 해당하는 URL 성능 테스트 수행
  - 테스트 수행 결과 50명의 가상 사용자가 최대 처리할 수 있는 사용자
    - 다시 말해서 사용자를 증가시키더라도 더 이상 초당 처리량은 증가하지 않는다.
  - 이때 초당 처리량 200건
    - 200 / 50 이므로 초당 처리량 4개
    - 그렇다면 스레드가 was default 인 200 개 까지도 필요 없음
    - 다만 80% 에 해당하는 값만 측정했으므로, 예상치 못한 병목이 있을 수도 있으므로 약 60 ~ 70 개 추천
    - 만약 병목을 제거했다면 자기 측정하고 계산하는 단계를 거쳐야 한다.
    - A 라는 병목을 제거하면 B 라는 병목이 부각되고 B 를 제거하면 C 가 부각... 이러한 과정을 거쳐 서비스를 안정화 해야한다.
  - tomcat 과 같은 WAS 는 초기 스레드 개수와 최대 스레드 개수를 정한다고 해도 처음부터 그 개수만큼 스레드 풀을 생성하지는 않는다.
    - 스레드가 부족할 경우 스레드를 증가하는 방식을 사용한다
      - 10개를 요청했는데, 빌려줄 스레드가 없을 때
    - 단, WAS 에서 설정한 최대 스레드 개수에 도달하면, 더이상 스레드를 생성하지 않고 수행 중인 스레드들이 종료할 때까지 기다린다.

<br />

### 스레드에서 발생하는 문제 중 가장 대표적인 것
- 스레드에서 일어나는 가장 대표적인 문제는 lock
- lock 이 풀리지 않기나, 풀리기만을 여러 스레드가 대기한다면 문제가 될 수 있다.
- 치명적인 경우 서버에 hang 이 걸려 응답이 업섹 된다.
- 대표적인 문제들
  - race condition
    - 공유 데이터를 처리할 때 여러 스레드에서 데이터를 수정해 엉망이 될 수 있음
    - 내가 보고서를 만들었는데 여러 높은 사람들이 수정하라고 지시를 내리는 것...
  - deadlock
    - 데이터를 안전하게 처리하기 위한 lock 에서 문제가 발생할 수 도 있음
    - 2개 이상의 스레드에서 lock 이 풀리기만을 기다리는 상황
      - 스레드 1이 DataA 에 lock 을 건 상태에서 DataB 에 접근
      - 스레드 2가 DataB 에 lock 을 건 상태에서 DataA 에 접근
    - 연인이 싸우고 난 뒤에 자존심 떄문에 상대방이 먼저 전화하기를 기다리는 경우...
    - deadlock.java 에 예시를 적어 두었음
  - starvation
    - 데드록과 비슷하지만, 원인은 그렇지 않다.
    - 멈춘 스레드가 이론적으로 수행할 수 있지만 CPU 로부터 일할 기회를 받지 못하는 경우
    - 우선순위에 밀려 기회를 받지 못하는 것
  - live lock
    - 하나의 스레드에서 다른 스레드로 응답을 주는 경우
      - 응답을 받은 스레드에서 요청했던 스레드로 다시 용청을 하는 작업 반복
      - 이것을 live lock 이라고 한다.
      - 라이브 락은 데드록과 달리 지속해서 수행하므로 CPU 까지 점유할 확률이 높다.
      - CPU 코어 하나를 모두 점유할 수 있으니 CPU 사용량 모니터링 필요
  - nondeterminism
    - 예측 불가능한 오류
    - 예를 들면, 별도로 수행되는 멀티 스레드 프로그램이 있는데 경우에 따라 결과가 달라지는 경우

<br />

### 록 경합을 피하는 10 + 1 가지 방법
1. 코드가 아닌 데이터를 보호하라(Protect data, not code)
   - 데이터만 synchronized 블록으로 감싼다면 중요한 코드를 잠그는 데 수행하는 시간을 줄일 수 있다.
2. 락 사용 부분에서는 비싼 계산을 하지 말아라
   - 재정렬 작업을 짧게 하고 임시 변수를 사용하는 등의 작업으로 록에서 소요하는 시간을 줄일 수 있다.
3. 락을 분리해라 (lock striping)
   - 배열 요소들이 서로 다른 록을 갖도록 분산
   - 서로 다른 데이터에는 서로 다른 록을 사용하라
4. 내부적인 록이나 atomic 작업을 사용햇라
   - 필자 각주 : CAS 갖은 걸 얘기하는듯
5. 동기화된 데이터 구조를 사용하라
   - 만약 atomic 연산을 직접 사용할 수 없다면 내부적으로 atomic 을 사용하는 데이터 구조를 사용할 수 있다.
   - lock-free 메세지 큐가 대표적이다.
   - 필자 각주 : concurrenthashmap
6. 가능하다면 읽기-쓰기 록 디자인 패턴을 사용하라
   - reader - writer lock
   - 필자 각주 : reentrant lock
7. 가능하다면 읽기 전용 데이터를 사용하라
8. 객체 풀링을 피하라
   - 객체를 pool 에 저장해서 다시 재사용 하는 것을 피하라
9. 지역 변수를 사용하거나 스레드 로컬 저장소를 사용하라
10. 핫스팟을 피하라
    - 핫스팟은 매우 잦은 변경이 일어나는 리소스 중 하나다.
    - 만약 linked list 를 저장하고 있고, size 가 변경 될 때마다 size 변수를 수정해야 하고 작업을 수행하는 메서드는 동시 접근을 처리하기 위해 보호되어야 한다
      - 이것을 핫스팟이라고 한다.
    - 가장 쉬운 방법은 linked list 의 사이즈를 저장하지 않는 것(...?)
      - 데이터가 늘어날 수록 사이즈를 직접 찾는 비용이 늘어날 것...
      - 적절한 트레이드오프를 찾아야 한다
11. 트랜잭션을 제공하는 메모리 시스템을 사용하라
    - 트랜잭션을 처리하는 메모리는 록을 처리하기 위해 복잡한 부분을 없애주기 때문에 매우 정제된 록의 모든 장점을 제공할 것이다.
    - 다만, 실제 운영 상황에서 적용할 수 있는 트랜잭션 처리가 가능한 메모리는 찾지 못했음...

<br />

### 끝나지 않는 루프
- 무한 루프
  - while true
  - xml parsing
  - lib error
  - regex 를 잘못 쓰는 경우
  - 이럴 경우 OOM 발생!